from __future__ import annotations

import json
from pathlib import Path

from oss_fuzz.project.models import Project
from oss_fuzz.sandbox.contexts import SandboxContext
from pydantic import BaseModel, field_serializer

from .schemas import PathStr


class Vulnerability(BaseModel):
    directory: PathStr

    @field_serializer("directory")
    def serialize_directory(self, value: Path) -> str:
        return str(value)

    @property
    def project(self) -> Project:
        return Project(directory=self.directory.parent.parent)

    @property
    def metadata(self) -> _VulnerabilityMetadata:
        return _VulnerabilityMetadata.from_vulnerability_directory(self.directory)

    @property
    def as_sandbox_context(self) -> SandboxContext:
        sources_directory = self.project.directory / "sources"
        source_directory = sources_directory / self.metadata.base_commit
        if not source_directory.is_dir():
            raise FileNotFoundError(f"Source directory not found: {source_directory}. ")
        candidate_directories = list((source_directory / "src").iterdir())

        if len(candidate_directories) != 1:
            raise RuntimeError(
                f"Expected exactly one source directory in {source_directory}, "
                f"but found {len(candidate_directories)}."
            )

        directory = candidate_directories[0]

        return SandboxContext(
            project_name=self.project.name,
            version=self.metadata.name,
            project_directory=self.project.directory,
            source_directory=(directory, Path("/src") / directory.name),
            sanitizer=self.metadata.sanitizer,
            fuzzing_language=self.project.metadata.language,
            proof=self.metadata.proof,
            harness=self.metadata.harness,
            # initial_crash_log=self.metadata.crash_log,
        )


class _VulnerabilityMetadata(BaseModel):
    name: str
    harness: str
    sanitizer: str
    error_token: str
    base_commit: str
    crash_log: bytes
    proof: bytes

    @staticmethod
    def from_vulnerability_directory(directory: Path) -> _VulnerabilityMetadata:
        metadata_file = directory / "index.json"
        if not metadata_file.exists():
            raise FileNotFoundError(f"Metadata file not found: {metadata_file}")

        return _VulnerabilityMetadata.model_validate(
            {
                **json.loads(metadata_file.read_text(encoding="utf-8")),
                "crash_log": (directory / "crash.log").read_text(
                    encoding="utf-8", errors="ignore"
                ),
                "proof": (directory / "proof.bin").read_bytes(),
            }
        )


class VulnerabilityCollection(list[Vulnerability]):
    @staticmethod
    def from_project(project: Project) -> VulnerabilityCollection:
        return VulnerabilityCollection(
            Vulnerability(directory=directory)
            for directory in (project.directory / "vulnerabilities").iterdir()
            if directory.is_dir() and (directory / "index.json").exists()
        )
