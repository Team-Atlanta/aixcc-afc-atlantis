import logging
from typing import Optional, TypedDict

from langgraph.graph import END, START, StateGraph
from langgraph.graph.state import CompiledGraph

from vuli.blobgen import BlobGeneratorResult, PoVGenerator
from vuli.codereader import BaseReader
from vuli.cp import CP
from vuli.model_manager import ModelManager
from vuli.struct import CodePoint, Sanitizer


class State(TypedDict):
    code_table: dict
    harness_id: str
    path: list[CodePoint]
    prev: BlobGeneratorResult
    point: str
    sanitizer: Sanitizer
    crash: bool = False


class Exploit:
    def __init__(self, generator: PoVGenerator):
        self._logger = logging.getLogger("exploit")
        self._log_prefix: str = ""
        self._generator = generator
        self._reader = BaseReader(CP().source_dir)

    def _log(self, msg: str) -> str:
        if len(self._log_prefix) == 0:
            return msg
        return f"[{self._log_prefix}] {msg}"

    def compile(self) -> CompiledGraph:
        graph = StateGraph(State)
        graph.add_node("prepare", self.prepare)
        graph.add_node("generate_blob", self.generate_blob)
        graph.add_edge(START, "prepare")
        graph.add_edge("prepare", "generate_blob")
        graph.add_edge("generate_blob", END)
        return graph.compile()

    def prepare(self, state: dict) -> dict:
        if not isinstance(state.get("code_table", None), dict):
            raise RuntimeError("Invalid Input (code_table)")
        if not isinstance(state.get("harness_id", None), str):
            raise RuntimeError("Invalid Input (harness_id)")
        if not isinstance(state.get("path", None), list):
            raise RuntimeError("Invalid Input (path)")
        if not isinstance(state.get("prev", None), BlobGeneratorResult):
            raise RuntimeError("Invalid Input (prev)")
        if not isinstance(state.get("point", None), str):
            raise RuntimeError("Invalid Input (point)")
        if not isinstance(state.get("sanitizer", None), Sanitizer):
            raise RuntimeError("Invalid Input (sanitizer)")

        state["crash"] = False
        return state

    async def generate_blob(self, state: dict) -> dict:
        code: str = await BaseReader(CP().source_dir).read_by_table(state["code_table"])
        best_result: Optional[BlobGeneratorResult] = None
        for model_name in ModelManager().get_all_model_names():
            result: BlobGeneratorResult = await self._generator.generate(
                code,
                state["harness_id"],
                [model_name],
                state["path"],
                state["point"],
                state["prev"],
                state["sanitizer"],
            )
            self._logger.info(
                self._log(
                    f"Finished Blob Generation [model={model_name}, score={result.eval.score}]"
                )
            )
            if best_result is None or best_result.eval.score < result.eval.score:
                best_result = result
            if best_result.eval.score == 1.0:
                break

        if best_result is None:
            self._logger.info(self._log("Failed Blob Generation"))
            return state

        improve: bool = best_result.eval.score == 1.0
        if improve:
            state["crash"] = True
            state["prev"] = result
        return state
