# libSarif

A Python library for analyzing and manipulating call graphs.

## Installation

```bash
pip install libsarif
```

## Usage

### CallGraph

The main class for working with call graphs. It provides functionality to create, manipulate, and analyze call graphs.

```python
from libSarif import CallGraph

# Load from JSON file
callgraph = CallGraph.from_json("path/to/callgraph.json")

```

NOTE: The callgraph json file is available in the shared library of crs-sarif.


### Function Analysis

The library provides several functions for analyzing call graphs:
If the line is not rechable, returns None.

#### About include_uncertain Option

The `include_uncertain` option determines whether to include uncertain edges in the analysis. In call graphs, edges can be classified as:
- Strong edges: Direct function calls or virtual calls with a single target
- Weak edges: Indirect function calls or virtual calls with multiple possible targets

When `include_uncertain=False` (default), only strong edges are considered, providing more precise but potentially incomplete results.
When `include_uncertain=True`, both strong and weak edges are considered, providing more complete but potentially less precise results.

#### get_rechable_function_with_line

Find a function that contains a specific line number in a file.

If the line is not rechable, returns None.

A Function object contains the following information:

```python
class Function(BaseModel):
    func_name: str
    file_name: str # absolute path
    class_name: str | None = None
    func_sig: str | None = None
    method_desc: str | None = None
    start_line: int 
    end_line: int
```

For example:
```python
from libSarif import get_rechable_function_with_line
from libSarif.models import Function

# Find function containing line 42 in file.c
function = get_rechable_function_with_line(callgraph, "file.c", 42)

# Include uncertain edges in the search
function = get_rechable_function_with_line(callgraph, "file.c", 42, include_uncertain=True)
```



#### get_subgraph

Get a subgraph containing all paths from the entrypoint to a target function.

This can be used when you want to keep a call graph associated with a target for memory efficiency.

```python
from libSarif import get_subgraph

# Get subgraph for a specific function
# target_function: Function
subgraph = get_subgraph(callgraph, target_function)
```

#### get_paths

**IMPORTANT: This function can be very slow depending on the size of the callgraph, so use it with caution.**

Get all possible paths from the entrypoint to a target function.

Returns a list of paths, where each path is a list of Function objects representing the sequence of function calls from the entrypoint to the target function.
If no path is found, returns an empty list.

```python
from libSarif import get_paths
# target_function: Function

# Get all paths to a function
paths = get_paths(callgraph, target_function)
# paths: list[list[Function]]

# Include uncertain edges in the paths
paths = get_paths(callgraph, target_function, include_uncertain=True)
```

#### get_shortest_path

Get the shortest path from the entrypoint to a target function.

Returns a list of Function objects representing the sequence of function calls in the shortest path from the entrypoint to the target function.
If no path is found, returns an empty list.

```python
from libSarif import get_shortest_path

# target_function: Function

# Get shortest path to a function
path = get_shortest_path(callgraph, target_function)
# path: list[Function]

# Include uncertain edges in the path
path = get_shortest_path(callgraph, target_function, include_uncertain=True)
```

## Function Model

The `Function` class represents a function in the call graph with the following attributes:

- `func_name`: Name of the function
- `file_name`: Absolute path to the file containing the function
- `class_name`: Class name (for Java methods)
- `func_sig`: Function signature
- `method_desc`: Method descriptor (for Java methods)
- `start_line`: Starting line number of the function
- `end_line`: Ending line number of the function


## Error Handling

The library includes error handling for common scenarios:

- `NodeNotFound`: Raised when a requested node is not found in the graph
- `ValueError`: Raised for invalid operations or missing required fields

## Logging

The library uses the `loguru` logger for logging. You can configure the logging level and format as needed.


## Example:

```python
from libSarif import (
    CallGraph,
    get_rechable_function_with_line,
    get_subgraph,
    get_shortest_path,
    get_paths,
)
from libSarif.models import Function


if __name__ == "__main__":
    # Load call graph from a JSON file
    # The JSON file contains the call graph information generated by the static analysis tool
    callgraph_path = "/for/example/uri-12ea28bdc6528f144004db0a1a3226cf.json"
    callgraph = CallGraph().from_json(callgraph_path)

    # Find a function that contains line 9820 in xmlschemas.c
    # include_uncertain=True means we'll also consider indirect function calls
    rechable_function: Function | None = get_rechable_function_with_line(
        callgraph, "xmlschemas.c", 9820, include_uncertain=True
    )

    if rechable_function:
        # Print the found function's information
        print(rechable_function)

        # Create a subgraph containing only the paths from entrypoint to the target function
        # This is more memory efficient than working with the entire call graph
        subgraph = get_subgraph(callgraph, rechable_function)

        # Get all possible paths from entrypoint to the target function
        # This will only consider direct function calls (strong edges)
        print(get_paths(subgraph, rechable_function))

        # Get all possible paths including indirect function calls (weak edges)
        # We take the first path ([0]) as an example
        print(get_paths(subgraph, rechable_function, include_uncertain=True)[0])

        # Get the shortest path considering only direct function calls
        print(get_shortest_path(subgraph, rechable_function))

        # Get the shortest path including indirect function calls
        print(get_shortest_path(subgraph, rechable_function, include_uncertain=True))

    print("done")
```