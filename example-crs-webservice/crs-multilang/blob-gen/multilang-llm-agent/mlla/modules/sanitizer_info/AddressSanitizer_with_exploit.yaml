BufferOverflow:
  description: |-
    Writing past allocated memory boundaries.

    Look for: Array/buffer access where index can exceed size.
    ```c
    int arr[10];
    for(int i = 0; i <= 10; i++) arr[i] = i;  // BUG: arr[10] out of bounds

    char buf[8];
    strcpy(buf, user_input);  // BUG: user_input might be > 8 bytes

    int data[5];
    data[get_user_input()] = 42;  // BUG: index might be >= 5
    ```

  exploit: |-
    1. Find vulnerable buffer/array
    2. Control index/size input
    3. Provide input exceeding boundaries

    ```c
    char* buf = malloc(8);
    strcpy(buf, "This string is too long");  // Triggers overflow
    ```

BufferUnderflow:
  description: |-
    Writing before allocated memory start.

    Look for: Array access with negative indices or backward pointer arithmetic.
    ```c
    int arr[10];
    arr[-1] = 42;  // BUG: negative index

    char buf[20];
    int offset = get_user_input();
    buf[offset - 5] = 'A';  // BUG: if offset < 5, negative index
    ```

  exploit: |-
    1. Find buffer with potential negative access
    2. Control index calculation
    3. Provide input making index negative

    ```c
    char buf[8];
    buf[-1] = 'A';  // Triggers underflow
    ```

UseAfterFree:
  description: |-
    Accessing heap memory after free().

    Look for: Pointer usage after free() without setting to NULL.
    ```c
    char* ptr = malloc(100);
    free(ptr);
    printf("%s", ptr);  // BUG: use after free

    if (error) free(data);
    data[0] = 42;  // BUG: might be freed
    ```

  exploit: |-
    1. Find memory that gets freed
    2. Locate access after free
    3. Trigger the access path

    ```c
    int* ptr = malloc(sizeof(int));
    free(ptr);
    *ptr = 42;  // Triggers use-after-free
    ```

UseAfterReturn:
  description: |-
    Accessing stack memory after function return.

    Look for: Functions returning addresses of local variables.
    ```c
    int* get_number() {
        int local = 42;
        return &local;  // BUG: returning stack address
    }
    ```

  exploit: |-
    1. Find function returning stack address
    2. Use returned pointer after function returns

    ```c
    int* ptr = get_number();
    printf("%d", *ptr);  // Triggers use-after-return
    ```

DoubleFree:
  description: |-
    Calling free() twice on same memory.

    Look for: Multiple free() calls without ptr = NULL between them.
    ```c
    char* ptr = malloc(100);
    free(ptr);
    free(ptr);  // BUG: double free

    if (error) free(data);
    if (data != NULL) free(data);  // BUG: data still not NULL after free
    ```

  exploit: |-
    1. Find memory freed multiple times
    2. Trigger both free paths

    ```c
    char* buf = malloc(100);
    free(buf);
    free(buf);  // Triggers double free
    ```

UseBeforeInitialization:
  description: |-
    Using variables before proper initialization (local or global).

    Look for: Uninitialized pointers, NULL dereference, cross-file global dependencies.
    ```c
    char* ptr;  // Uninitialized local pointer
    *ptr = 'A';  // BUG: use before initialization

    char* ptr = NULL;
    *ptr = 'B';  // BUG: NULL pointer dereference
    ```
    ```cpp
    // file1.cpp: std::string global_config = "default";
    // file2.cpp: extern std::string global_config;
    struct Init { Init() { std::cout << global_config; } };
    Init init;  // BUG: global_config might not be initialized
    ```

  exploit: |-
    1. Find uninitialized variable usage
    2. Trigger access before initialization

    ```c
    char* ptr = NULL;
    *ptr = 'A';  // Triggers NULL pointer dereference
    ```

FloatingPointException:
  description: |-
    Division or modulo by zero.

    Look for: Division/modulo where divisor can be zero.
    ```c
    int result = 10 / 0;  // BUG: immediate division by zero

    int divisor = get_user_input();
    int result = 100 / divisor;  // BUG: divisor might be 0
    ```

  exploit: |-
    1. Find division/modulo operation
    2. Control divisor input
    3. Provide zero as divisor

    ```c
    int divisor = 0;
    int result = 10 / divisor;  // Triggers SIGFPE
    ```

TimeoutDenialOfService:
  description: |-
    Infinite loops from user input.

    Look for: Loops/recursion where user controls termination.
    ```c
    int count = get_user_input();
    while(count > 0) {
        process();  // BUG: missing count--
    }

    void recurse(int n) {
        if (n <= 0) return;
        recurse(n);  // BUG: should be recurse(n-1)
    }
    ```

  exploit: |-
    1. Find user-controlled loop/recursion
    2. Provide input preventing termination

    ```c
    int count = 1;  // Any positive number
    while(count > 0) {
        printf("loop");  // Infinite loop - missing count--
    }
    ```
