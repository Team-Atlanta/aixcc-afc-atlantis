FloatingPointException:
  description: |-
    Detects undefined behavior caused by integer division by zero or signed integer overflow that triggers a floating point exception (SIGFPE). The sanitizer monitors arithmetic operations at runtime and aborts execution upon detecting invalid calculations.

    C/C++ Example Patterns:

    ```c
    // Division by zero
    int a = 10;
    int b = 0;
    int c = a / b;  // Triggers SIGFPE

    // Modulo by zero
    int a = 10;
    int b = 0;
    int c = a % b;  // Triggers SIGFPE

    // Signed integer overflow (if not compiled with -fno-strict-overflow)
    int x = INT_MAX;
    int y = x + 1;  // Undefined behavior; may trigger sanitizer depending on config
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
      - The sanitizer hooks arithmetic operations at runtime and checks for:
        * Integer division by zero
        * Modulo by zero
        * (Optional) Signed integer overflow if compiled with UBSan or certain ASan options

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address` (or `-fsanitize=undefined` for UB)
        * `-fno-omit-frame-pointer`, `-g` for better diagnostics
        * `-O1` or higher optimization level to enable sanitizer checks
      - Triggering expression must be evaluated at runtime (not constant-folded by compiler)

    3. Valid Exploit Patterns - Use ONLY these:

    ```c
      // Division by zero
      #include <stdio.h>
      int main() {
          int x = 10;
          int y = 0;
          int z = x / y;  // Will trigger AddressSanitizer SIGFPE
          printf("%d\n", z);
          return 0;
      }

      // Modulo by zero
      #include <stdio.h>
      int main() {
          int a = 42;
          int b = 0;
          int c = a % b;  // Will trigger SIGFPE
          return 0;
      }
    ```

heap-buffer-overflow:
  description: |-
    Detects illegal memory access beyond the boundaries of a heap-allocated buffer.
    The sanitizer instruments dynamic memory allocations (e.g., malloc, new) and
    inserts redzones to detect out-of-bounds reads or writes at runtime.

    Violations occur when:
    - Writing past the end of a dynamically allocated array
    - Reading uninitialized or freed heap memory
    - Accessing memory with an incorrect pointer arithmetic offset

    C/C++ Example Patterns:

    ```c
    #include <stdlib.h>
    #include <string.h>

    int main() {
        char* buf = (char*)malloc(10);
        buf[10] = 'A';  // Heap-buffer-overflow: index 10 is out of bounds
        free(buf);
        return 0;
    }

    // Overflow with memcpy
    #include <stdlib.h>
    #include <string.h>

    int main() {
        char* dst = (char*)malloc(5);
        char* src = "HelloWorld";
        memcpy(dst, src, 10);  // Writes past the end of dst
        free(dst);
        return 0;
    }
    ```

  exploit: |-
    To generate a valid exploit for this sanitizer, follow these strict requirements:

    1. Target Implementation:
      - The sanitizer monitors memory access to dynamically allocated buffers via malloc, calloc, new, etc.
      - Redzones are placed before and after the allocated region to detect overflow

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address`
        * `-fno-omit-frame-pointer`, `-g` for proper stack trace
        * Optimization level `-O1` or higher (recommended)
      - Trigger must perform an actual out-of-bounds access at runtime

    3. Valid Exploit Patterns - Use ONLY these:

    ```c
    #include <stdlib.h>

    int main() {
        int* data = (int*)malloc(4 * sizeof(int));
        for (int i = 0; i <= 4; i++) {
            data[i] = i;  // Overwrites memory beyond allocated buffer
        }
        free(data);
        return 0;
    }

    #include <string.h>
    #include <stdlib.h>

    int main() {
        char* buf = (char*)malloc(8);
        strcpy(buf, "TooLongString");  // Writes past buffer size
        free(buf);
        return 0;
    }
    ```

heap-use-after-free:
  description: |-
    Detects undefined behavior where memory is accessed after it has been freed. This can lead to data corruption, crashes, or security vulnerabilities such as remote code execution. The sanitizer monitors memory deallocations and subsequent access to those memory regions.

    C/C++ Example Patterns:

    ```c
    // Basic heap use-after-free
    #include <stdlib.h>
    int main() {
        int* ptr = (int*)malloc(sizeof(int));
        *ptr = 42;
        free(ptr);
        int value = *ptr;  // Use-after-free: accessing freed memory
        return 0;
    }

    // Use-after-free with array
    #include <stdlib.h>
    int main() {
        int* arr = (int*)malloc(3 * sizeof(int));
        arr[0] = 1;
        free(arr);
        arr[2] = 99;  // Use-after-free: writing to freed memory
        return 0;
    }
    ```

  exploit: |-
    To trigger a heap-use-after-free detection reliably, follow these rules:

    1. Target Implementation:
      - The sanitizer instruments heap memory management functions (`malloc`, `free`, `new`, `delete`, etc.)
      - It tracks freed memory and flags any subsequent access (read or write)

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address`
        * `-fno-omit-frame-pointer`, `-g` for stack trace support
        * Use `-O1` or higher to enable full instrumentation

    3. Valid Exploit Patterns:

    ```c
    // Reading freed memory
    #include <stdlib.h>
    #include <stdio.h>
    int main() {
        int* p = (int*)malloc(sizeof(int));
        *p = 123;
        free(p);
        printf("%d\n", *p);  // Use-after-free read
        return 0;
    }

    // Writing to freed memory
    #include <stdlib.h>
    int main() {
        char* buf = (char*)malloc(100);
        free(buf);
        buf[0] = 'A';  // Use-after-free write
        return 0;
    }
    ```

stack-buffer-underflow:
  description: |-
    Detects reads or writes before the beginning of a local (stack-allocated) buffer. This type of bug arises when pointer arithmetic or incorrect indexing causes access to memory preceding the intended stack array. It may corrupt function metadata or lead to undefined behavior, including crashes and potential exploitation.

    C/C++ Example Patterns:

    ```c
    // Read before stack buffer
    #include <stdio.h>
    int main() {
        char buf[8];
        char val = buf[-1];  // Stack-buffer-underflow: reading before start of buffer
        printf("%c\n", val);
        return 0;
    }

    // Write before stack buffer
    #include <stdio.h>
    int main() {
        int arr[5] = {0};
        arr[-1] = 42;  // Stack-buffer-underflow: writing before buffer
        return 0;
    }
    ```

  exploit: |-
    To trigger a stack-buffer-underflow condition and have it detected reliably by AddressSanitizer, adhere to the following:

    1. Target Implementation:
      - The sanitizer tracks memory regions on the stack and adds red zones before and after local variables to detect out-of-bounds access.

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address`
        * `-fno-omit-frame-pointer`, `-g` for accurate diagnostics
        * Optimization level `-O1` or higher to ensure instrumentation
      - Buffer must be allocated on the stack, and the access must occur before its base address.

    3. Valid Exploit Patterns:

    ```c
    // Stack buffer underflow via pointer
    #include <stdio.h>
    int main() {
        int buf[4] = {1, 2, 3, 4};
        int* p = buf;
        int x = *(p - 1);  // Read underflow
        printf("%d\n", x);
        return 0;
    }

    // Stack buffer underflow via negative index
    #include <stdio.h>
    int main() {
        char data[10];
        data[-2] = 'A';  // Write underflow
        return 0;
    }
    ```

initialization-order-fiasco:
  description: |-
    Detects use of global or static variables before their proper initialization due to incorrect ordering across translation units. This can result in undefined behavior, data corruption, or crashes when constructors of global objects in different files interact in unintended order.

    Typically occurs when a global object depends on another global object defined in a separate translation unit. The C++ standard does not guarantee initialization order across translation units, which leads to this type of bug.

    C++ Example Patterns:

    ```cpp
    // a.cpp
    #include <string>
    std::string global_str = "Hello";

    // b.cpp
    #include <iostream>
    extern std::string global_str;
    struct Accessor {
        Accessor() {
            std::cout << global_str << std::endl;  // May use global_str before it's initialized
        }
    };
    Accessor accessor;
    ```

    // Depending on the linker and object file order, this may print garbage or crash

  exploit: |-
    To trigger and detect an initialization-order-fiasco reliably with AddressSanitizer, follow these guidelines:

    1. Target Implementation:
      - The sanitizer instruments constructors of global/static objects and tracks their initialization across translation units.

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address` (ASan supports this check)
        * `-g`, `-fno-omit-frame-pointer` for diagnostics
        * Use multiple source files to create separate translation units
        * Compile and link with ASan enabled (i.e., link with `clang++ -fsanitize=address`)

    3. Valid Exploit Patterns:

    ```cpp
    // file1.cpp
    #include <string>
    std::string global_data = "Safe";

    // file2.cpp
    #include <iostream>
    extern std::string global_data;
    struct Logger {
        Logger() {
            std::cerr << "Using global_data: " << global_data << std::endl;
        }
    };
    Logger logger;
    ```

    // Build with:
    // clang++ -fsanitize=address -g -fno-omit-frame-pointer file1.cpp file2.cpp -o test_exec
    //
    // Depending on the initialization order, this may use `global_data` before it's constructed, and ASan will flag it.

stack-buffer-overflow:
  description: |-
    Detects writes or reads past the end of a local (stack-allocated) buffer. This vulnerability typically arises when an index or pointer exceeds the bounds of the allocated array on the stack, potentially corrupting adjacent memory, including return addresses or local variables. Exploitation may lead to crashes or arbitrary code execution, depending on the overwritten memory region.

    C/C++ Example Patterns:

    ```c
    // Write past end of stack buffer
    #include <stdio.h>
    int main() {
        char buf[8];
        buf[8] = 'A';  // Stack-buffer-overflow: writing beyond buffer
        return 0;
    }

    // Read past end of stack buffer
    #include <stdio.h>
    int main() {
        int arr[4] = {1, 2, 3, 4};
        int x = arr[4];  // Stack-buffer-overflow: reading beyond buffer
        printf("%d\n", x);
        return 0;
    }
    ```

  exploit: |-
    To reliably trigger a stack-buffer-overflow and have it detected by AddressSanitizer, follow these conditions:

    1. Target Implementation:
      - The sanitizer tracks stack-allocated buffers and places red zones (guard regions) around them to detect out-of-bounds memory accesses.

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address`
        * `-fno-omit-frame-pointer`, `-g` for better debugging information
        * `-O1` or higher optimization level to preserve instrumentation
      - The overflow must happen on a local buffer (allocated on stack) and extend past its end.

    3. Valid Exploit Patterns:

    ```c
    // Stack buffer overflow via indexing
    #include <stdio.h>
    int main() {
        int data[3] = {0};
        data[3] = 123;  // Write overflow
        return 0;
    }

    // Stack buffer overflow via pointer arithmetic
    #include <stdio.h>
    int main() {
        char buf[5];
        char* p = buf;
        p[5] = 'B';  // Write overflow beyond buffer
        return 0;
    }

    // Stack buffer overflow via loop
    #include <stdio.h>
    int main() {
        int array[2];
        for (int i = 0; i <= 2; i++) {  // Off-by-one error
            array[i] = i * 10;  // Overflow on i == 2
        }
        return 0;
    }
    ```

stack-use-after-return:
  description: |-
    Detects access to stack memory after the function that allocated it has returned. Occurs when a pointer to a local variable is returned from a function and later dereferenced. When the function returns, its stack frame is deallocated, making any access to that memory undefined behavior.

    C/C++ Example Patterns:

    ```c
    // Basic stack-use-after-return
    #include <stdio.h>

    int* get_stack_pointer() {
        int x = 42;
        return &x;  // Returns pointer to local variable
    }

    int main() {
        int* ptr = get_stack_pointer();
        printf("%d\n", *ptr);  // Use after return: accessing stack memory after function returned
        return 0;
    }

    // Stack-use-after-return with array
    #include <string.h>
    #include <stdio.h>

    char* get_string() {
        char buffer[10];
        strcpy(buffer, "Hello");
        return buffer;  // Returns pointer to stack-allocated array
    }

    int main() {
        char* str = get_string();
        printf("%s\n", str);  // Use after return: accessing freed stack memory
        return 0;
    }
    ```

  exploit: |-
    To trigger a stack-use-after-return detection with AddressSanitizer:

    1. Target Implementation:
      - The sanitizer instruments function returns and stack allocations
      - It detects when a pointer to a stack variable is used after the function that created it has returned

    2. Mandatory Requirements:
      - Must compile with:
        * `-fsanitize=address`
        * `-fno-omit-frame-pointer`, `-g` for better diagnostics
        * `-O1` or higher optimization level
        * Set environment variable `ASAN_OPTIONS=detect_stack_use_after_return=1`

    3. Valid Exploit Patterns:

    ```c
    // Simple stack-use-after-return exploit
    #include <stdio.h>

    int* create_dangling_pointer() {
        int local_var = 42;
        return &local_var;  // Return address of stack variable
    }

    int main() {
        int* ptr = create_dangling_pointer();
        printf("Value: %d\n", *ptr);  // AddressSanitizer will detect this access
        return 0;
    }

    // Stack-use-after-return with struct
    #include <stdio.h>
    #include <string.h>

    typedef struct {
        char data[10];
    } Buffer;

    Buffer* get_buffer() {
        Buffer local_buf;
        strcpy(local_buf.data, "test");
        return &local_buf;  // Return address of stack-allocated struct
    }

    int main() {
        Buffer* buf = get_buffer();
        printf("%s\n", buf->data);  // Will trigger AddressSanitizer
        return 0;
    }
    ```
