diff --git a/MODULE.bazel b/MODULE.bazel
index d3581686..aa8d840c 100644
--- a/MODULE.bazel
+++ b/MODULE.bazel
@@ -59,6 +59,7 @@ SHADED_RUNTIME_MAVEN_ARTIFACTS = [
     "com.google.errorprone:error_prone_annotations:2.26.1",
     "com.google.errorprone:error_prone_type_annotations:2.26.1",
     "io.github.classgraph:classgraph:jar:4.8.170",
+    "redis.clients:jedis:jar:5.2.0",
     "net.bytebuddy:byte-buddy-agent:1.14.13",
     "net.jodah:typetools:jar:0.6.3",
     "org.ow2.asm:asm:9.7",
@@ -125,7 +126,6 @@ VULNERABLE_TEST_MAVEN_ARTIFACTS = [
     "com.fasterxml.jackson.core:jackson-core:2.12.1",
     "com.fasterxml.jackson.core:jackson-databind:2.12.1",
     "com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.12.1",
-    "com.google.code.gson:gson:2.8.6",
     "com.h2database:h2:2.1.212",
     "com.mikesamuel:json-sanitizer:1.2.1",
     "com.unboundid:unboundid-ldapsdk:6.0.3",
@@ -227,6 +227,8 @@ http_archive(
     sha256 = "200b32c897b1171824462706f577d7f1d6175da602eccfe570d2dceeac11d490",
     strip_prefix = "llvm-project-jazzer-2023-04-25/compiler-rt/lib/fuzzer",
     url = "https://github.com/CodeIntelligenceTesting/llvm-project-jazzer/archive/refs/tags/2023-04-25.tar.gz",
+    patches = ["//third_party:libFuzzer.diff"],
+    patch_args = ["-p1"],
 )
 
 git_repository(
diff --git a/maven_install.json b/maven_install.json
index be61994e..f875c511 100755
--- a/maven_install.json
+++ b/maven_install.json
@@ -1,10 +1,11 @@
 {
   "__AUTOGENERATED_FILE_DO_NOT_MODIFY_THIS_FILE_MANUALLY": "THERE_IS_NO_DATA_ONLY_ZUUL",
-  "__INPUT_ARTIFACTS_HASH": 1598895504,
-  "__RESOLVED_ARTIFACTS_HASH": 564748184,
+  "__INPUT_ARTIFACTS_HASH": 576254710,
+  "__RESOLVED_ARTIFACTS_HASH": 1151990577,
   "conflict_resolution": {
-    "com.google.code.gson:gson:2.8.6": "com.google.code.gson:gson:2.8.9",
-    "com.google.errorprone:error_prone_annotations:2.3.2": "com.google.errorprone:error_prone_annotations:2.26.1",
+    "com.google.code.gson:gson:2.8.9": "com.google.code.gson:gson:2.11.0",
+    "com.google.errorprone:error_prone_annotations:2.26.1": "com.google.errorprone:error_prone_annotations:2.27.0",
+    "com.google.errorprone:error_prone_annotations:2.3.2": "com.google.errorprone:error_prone_annotations:2.27.0",
     "com.google.guava:guava:31.1-jre": "com.google.guava:guava:33.0.0-android",
     "com.google.j2objc:j2objc-annotations:1.3": "com.google.j2objc:j2objc-annotations:2.8",
     "com.google.truth:truth:1.1.2": "com.google.truth:truth:1.4.2",
@@ -73,15 +74,15 @@
     },
     "com.google.code.gson:gson": {
       "shasums": {
-        "jar": "d3999291855de495c94c743761b8ab5176cfeabe281a5ab0d8e8d45326fd703e"
+        "jar": "57928d6e5a6edeb2abd3770a8f95ba44dce45f3b23b7a9dc2b309c581552a78b"
       },
-      "version": "2.8.9"
+      "version": "2.11.0"
     },
     "com.google.errorprone:error_prone_annotations": {
       "shasums": {
-        "jar": "de25f2d9a2156529bd765f51d8efdfc0dfa7301e04efb9cc75b7f10cf5d0e0fb"
+        "jar": "24c923372c58e35d0b9f16a028929bb9aedc77521867c274f2bd0735df5ba1f5"
       },
-      "version": "2.26.1"
+      "version": "2.27.0"
     },
     "com.google.errorprone:error_prone_type_annotations": {
       "shasums": {
@@ -275,6 +276,12 @@
       },
       "version": "3.6.1"
     },
+    "org.apache.commons:commons-pool2": {
+      "shasums": {
+        "jar": "6d3bd18df8410f3e31b031aca582cc109342358a62a2759ebd0c4cdf30d06f8b"
+      },
+      "version": "2.12.0"
+    },
     "org.apache.commons:commons-text": {
       "shasums": {
         "jar": "0812f284ac5dd0d617461d9a2ab6ac6811137f25122dfffd4788a4871e732d00"
@@ -473,6 +480,12 @@
       },
       "version": "13.0"
     },
+    "org.json:json": {
+      "shasums": {
+        "jar": "3cf6cd6892e32e2b4c1c39e0f52f5248a2f5b37646fdfbb79a66b46b618414ed"
+      },
+      "version": "20240303"
+    },
     "org.junit.jupiter:junit-jupiter-api": {
       "shasums": {
         "jar": "3e370bcbb1e857fda5f0b203724116d02b05e788faa1eb2518814accf9cfb5b1"
@@ -569,6 +582,12 @@
       },
       "version": "9.7"
     },
+    "org.slf4j:slf4j-api": {
+      "shasums": {
+        "jar": "d3ef575e3e4979678dc01bf1dcce51021493b4d11fb7f1be8ad982877c16a1c0"
+      },
+      "version": "1.7.36"
+    },
     "org.springframework:spring-aop": {
       "shasums": {
         "jar": "de43e11b649cbc0294dc6d7a5fd82c2b07a55114a5b6558d776c115ad5719a16"
@@ -623,6 +642,12 @@
       },
       "version": "6.1.4"
     },
+    "redis.clients:jedis": {
+      "shasums": {
+        "jar": "dd4fbda2c103f319ab495adb2bc1906139840746cfd4c66b27710d1af98382d4"
+      },
+      "version": "5.2.0"
+    },
     "xalan:serializer": {
       "shasums": {
         "jar": "e8f5b4340d3b12a0cfa44ac2db4be4e0639e479ae847df04c4ed8b521734bb4a"
@@ -661,6 +686,9 @@
       "com.fasterxml.jackson.core:jackson-core",
       "com.fasterxml.jackson.core:jackson-databind"
     ],
+    "com.google.code.gson:gson": [
+      "com.google.errorprone:error_prone_annotations"
+    ],
     "com.google.guava:guava": [
       "com.google.code.findbugs:jsr305",
       "com.google.errorprone:error_prone_annotations",
@@ -944,6 +972,12 @@
       "org.springframework:spring-expression",
       "org.springframework:spring-web"
     ],
+    "redis.clients:jedis": [
+      "com.google.code.gson:gson",
+      "org.apache.commons:commons-pool2",
+      "org.json:json",
+      "org.slf4j:slf4j-api"
+    ],
     "xalan:serializer": [
       "xml-apis:xml-apis"
     ],
@@ -1541,6 +1575,11 @@
       "org.apache.commons.math3.transform",
       "org.apache.commons.math3.util"
     ],
+    "org.apache.commons:commons-pool2": [
+      "org.apache.commons.pool2",
+      "org.apache.commons.pool2.impl",
+      "org.apache.commons.pool2.proxy"
+    ],
     "org.apache.commons:commons-text": [
       "org.apache.commons.text",
       "org.apache.commons.text.diff",
@@ -1993,6 +2032,9 @@
       "org.intellij.lang.annotations",
       "org.jetbrains.annotations"
     ],
+    "org.json:json": [
+      "org.json"
+    ],
     "org.junit.jupiter:junit-jupiter-api": [
       "org.junit.jupiter.api",
       "org.junit.jupiter.api.condition",
@@ -2184,6 +2226,12 @@
     "org.ow2.asm:asm-tree": [
       "org.objectweb.asm.tree"
     ],
+    "org.slf4j:slf4j-api": [
+      "org.slf4j",
+      "org.slf4j.event",
+      "org.slf4j.helpers",
+      "org.slf4j.spi"
+    ],
     "org.springframework:spring-aop": [
       "org.aopalliance.aop",
       "org.aopalliance.intercept",
@@ -2484,6 +2532,34 @@
       "org.springframework.web.servlet.view.xml",
       "org.springframework.web.servlet.view.xslt"
     ],
+    "redis.clients:jedis": [
+      "redis.clients.jedis",
+      "redis.clients.jedis.annots",
+      "redis.clients.jedis.args",
+      "redis.clients.jedis.bloom",
+      "redis.clients.jedis.bloom.commands",
+      "redis.clients.jedis.commands",
+      "redis.clients.jedis.csc",
+      "redis.clients.jedis.csc.util",
+      "redis.clients.jedis.exceptions",
+      "redis.clients.jedis.executors",
+      "redis.clients.jedis.gears",
+      "redis.clients.jedis.gears.resps",
+      "redis.clients.jedis.graph",
+      "redis.clients.jedis.graph.entities",
+      "redis.clients.jedis.json",
+      "redis.clients.jedis.json.commands",
+      "redis.clients.jedis.mcf",
+      "redis.clients.jedis.params",
+      "redis.clients.jedis.providers",
+      "redis.clients.jedis.resps",
+      "redis.clients.jedis.search",
+      "redis.clients.jedis.search.aggr",
+      "redis.clients.jedis.search.querybuilder",
+      "redis.clients.jedis.search.schemafields",
+      "redis.clients.jedis.timeseries",
+      "redis.clients.jedis.util"
+    ],
     "xalan:serializer": [
       "org.apache.xml.serializer",
       "org.apache.xml.serializer.dom3",
@@ -2624,6 +2700,7 @@
       "org.apache.commons:commons-imaging",
       "org.apache.commons:commons-lang3",
       "org.apache.commons:commons-math3",
+      "org.apache.commons:commons-pool2",
       "org.apache.commons:commons-text",
       "org.apache.logging.log4j:log4j-api",
       "org.apache.logging.log4j:log4j-core",
@@ -2657,6 +2734,7 @@
       "org.jetbrains.kotlin:kotlin-stdlib",
       "org.jetbrains.kotlin:kotlin-stdlib-common",
       "org.jetbrains:annotations",
+      "org.json:json",
       "org.junit.jupiter:junit-jupiter-api",
       "org.junit.jupiter:junit-jupiter-engine",
       "org.junit.jupiter:junit-jupiter-params",
@@ -2673,6 +2751,7 @@
       "org.ow2.asm:asm",
       "org.ow2.asm:asm-commons",
       "org.ow2.asm:asm-tree",
+      "org.slf4j:slf4j-api",
       "org.springframework:spring-aop",
       "org.springframework:spring-beans",
       "org.springframework:spring-context",
@@ -2682,6 +2761,7 @@
       "org.springframework:spring-test",
       "org.springframework:spring-web",
       "org.springframework:spring-webmvc",
+      "redis.clients:jedis",
       "xalan:serializer",
       "xalan:xalan",
       "xml-apis:xml-apis",
diff --git a/src/main/java/com/code_intelligence/jazzer/agent/Agent.kt b/src/main/java/com/code_intelligence/jazzer/agent/Agent.kt
index 2463ff1d..e3aa4b7f 100644
--- a/src/main/java/com/code_intelligence/jazzer/agent/Agent.kt
+++ b/src/main/java/com/code_intelligence/jazzer/agent/Agent.kt
@@ -115,6 +115,11 @@ fun installInternal(
     val coverageIdSynchronizer =
         if (idSyncFilePath != null) {
             FileSyncCoverageIdStrategy(idSyncFilePath)
+        } else if (Opt.uniaflCoverage.get() && Opt.redisURL.get() != ""){
+            val ret = RedisSyncCoverageIdStrategy(Opt.redisURL.get())
+            if (Opt.uniaflPrepare.get()) { ret.prepare() }
+            if (Opt.uniaflDump.get()) { ret.dump() }
+            ret
         } else {
             MemSyncCoverageIdStrategy()
         }
diff --git a/src/main/java/com/code_intelligence/jazzer/agent/BUILD.bazel b/src/main/java/com/code_intelligence/jazzer/agent/BUILD.bazel
index 5bc3908f..c330db00 100644
--- a/src/main/java/com/code_intelligence/jazzer/agent/BUILD.bazel
+++ b/src/main/java/com/code_intelligence/jazzer/agent/BUILD.bazel
@@ -37,6 +37,7 @@ kt_jvm_library(
         "//src/main/java/com/code_intelligence/jazzer/utils:log",
         "//src/main/java/com/code_intelligence/jazzer/utils:manifest_utils",
         "@maven//:io_github_classgraph_classgraph",
+        "@maven//:redis_clients_jedis",
     ],
 )
 
diff --git a/src/main/java/com/code_intelligence/jazzer/agent/CoverageIdStrategy.kt b/src/main/java/com/code_intelligence/jazzer/agent/CoverageIdStrategy.kt
index bd7b5053..944cabd8 100644
--- a/src/main/java/com/code_intelligence/jazzer/agent/CoverageIdStrategy.kt
+++ b/src/main/java/com/code_intelligence/jazzer/agent/CoverageIdStrategy.kt
@@ -16,6 +16,9 @@
 
 package com.code_intelligence.jazzer.agent
 
+import redis.clients.jedis.Jedis
+import com.code_intelligence.jazzer.instrumentor.ClassInstrumentor
+import com.code_intelligence.jazzer.instrumentor.CoverageRecorder
 import com.code_intelligence.jazzer.utils.Log
 import java.nio.ByteBuffer
 import java.nio.channels.FileChannel
@@ -23,6 +26,7 @@ import java.nio.channels.FileLock
 import java.nio.file.Path
 import java.nio.file.StandardOpenOption
 import java.util.UUID
+import io.github.classgraph.ClassGraph
 
 /**
  * Indicates a fatal failure to generate synchronized coverage IDs.
@@ -71,6 +75,146 @@ class MemSyncCoverageIdStrategy : CoverageIdStrategy {
     }
 }
 
+class RedisSyncCoverageIdStrategy(val redisDomain: String): CoverageIdStrategy {
+    private var nextEdgeId = 0
+    private val jedis = Jedis(redisDomain.split(':')[0], redisDomain.split(':')[1].toInt())
+    private var lastReload = 0;
+
+    @Synchronized
+    override fun withIdForClass(className: String, block: (Int) -> Int) {
+        val nextEdgeId = getNextEdgeId(className)
+        if (nextEdgeId >= 0) {
+            block(nextEdgeId)
+        }
+    }
+
+    private fun getNextEdgeId(className: String): Int {
+        val id = jedis.get(className)
+        if (id != null) return id.toInt()
+		val luaScript = """
+                    if redis.call('EXISTS', KEYS[1]) == 1 then
+                        return tonumber(redis.call('GET', KEYS[1]))
+                    end
+					local NEXT = redis.call('GET', 'NEXT') 
+					local SIZE = redis.call('GET', KEYS[2]) 
+					if not NEXT then NEXT = 0 else NEXT = tonumber(NEXT) end 
+					if not SIZE then return -1 else SIZE= tonumber(SIZE) end 
+					redis.call('SET', KEYS[1], NEXT) 
+					redis.call('SET', 'NEXT', NEXT + SIZE)
+					return NEXT
+				""".trimIndent()
+        val result = jedis.eval(luaScript, listOf("key#${className}", "size#${className}"), listOf())
+        return (result as Long).toInt()
+    }
+    
+
+    public fun dump() {
+        while(true) {
+            val covFileName = readLine()!!
+            val dumpFileName = "$covFileName.json"
+            dumpCoverageUniAFL(dumpFileName, covFileName)
+            println("UNIAFL_COV_DONE")
+        }
+
+    }
+    
+    public fun dumpCoverageUniAFL(dumpFileName: String, covFileName:String) {
+        val bytes = java.io.File(covFileName).readBytes()
+        val buffer = java.nio.ByteBuffer.wrap(bytes).order(java.nio.ByteOrder.LITTLE_ENDIAN) 
+        val coveredIds = IntArray(bytes.size / Long.SIZE_BYTES)
+        var needReload = false
+        for (i in coveredIds.indices) {
+          val tmp = buffer.long.toInt()
+          coveredIds[i] = tmp
+          if (tmp > lastReload) needReload = true
+        }
+        if(needReload) reload()
+        CoverageRecorder.dumpCoverageUniAFL(dumpFileName, coveredIds)
+    }
+
+    public fun reload() {
+        val last = jedis.get("NEXT")
+        if (last != null) {
+            if (lastReload >= last.toInt()) return
+            lastReload = last.toInt()
+        }
+		val keys = jedis.keys("key#*").toTypedArray()
+        val firstIds = mutableMapOf<String, Int>()
+        val sizes = mutableMapOf<String, Int>()
+
+		if (keys.isNotEmpty()) {
+			val firstIdValues: List<String?> = jedis.mget(*keys)
+            val sizeValues = jedis.mget(*keys.map{x -> "size#" + x.substring(4)}.toTypedArray())
+            for (i in 0 until keys.size) {
+                val name = keys[i].substring(4)
+                firstIds[name] = firstIdValues[i]!!.toInt()
+                sizes[name] = sizeValues[i]!!.toInt()
+            }
+		}
+        ClassGraph()
+            .enableClassInfo()
+            .enableSystemJarsAndModules()
+            .acceptLibOrExtJars()
+            .ignoreClassVisibility()
+            .rejectPackages(
+                // Always exclude Jazzer-internal packages (including ClassGraph itself) from coverage reports. Classes
+                // from the Java standard library are never traversed.
+                "com.code_intelligence.jazzer.*",
+                "jaz",
+            )
+            .scan().use { result ->
+                result.allClasses
+                    .asSequence()
+                    .filter { classInfo -> 
+                        val name = classInfo.name.replace(".","/")
+                        !CoverageRecorder.hasInstrumentedClass(name) 
+                        && name in firstIds
+                    }
+                    .forEach {classInfo -> 
+                        classInfo.resource.use { resource ->
+                            val name = classInfo.name.replace(".","/")
+                            val bytecode = resource.load()
+                            CoverageRecorder.recordInstrumentedClass(name, bytecode, firstIds[name]!!, sizes[name]!!)
+                        }
+                    }
+            }
+    }
+
+    public fun prepare() {
+        var total = 0
+        ClassGraph()
+            .enableClassInfo()
+            .enableSystemJarsAndModules()
+            .acceptLibOrExtJars()
+            .ignoreClassVisibility()
+            .rejectPackages(
+                // Always exclude Jazzer-internal packages (including ClassGraph itself) from coverage reports. Classes
+                // from the Java standard library are never traversed.
+                "com.code_intelligence.jazzer.*",
+                "jaz",
+            )
+            .scan().use { result ->
+                result.allClasses
+                    .asSequence()
+                    .forEach {classInfo -> 
+                        classInfo.resource.use { resource ->
+                            val name = classInfo.name.replace(".","/")
+                            val bytecode = resource.load()
+                            ClassInstrumentor(name, bytecode).run {
+                                val edges = coverage(total);
+                                jedis.set("size#${name}", edges.toString())
+                                total += edges
+                            }
+                        }
+                    }
+            }
+        kotlin.system.exitProcess(0)
+    }
+
+
+
+}
+
 /**
  * A strategy for coverage ID generation that synchronizes the IDs assigned to a class with other processes via the
  * specified [idSyncFile].
diff --git a/src/main/java/com/code_intelligence/jazzer/driver/ExceptionUtils.kt b/src/main/java/com/code_intelligence/jazzer/driver/ExceptionUtils.kt
index 36c6cea3..92b624d5 100644
--- a/src/main/java/com/code_intelligence/jazzer/driver/ExceptionUtils.kt
+++ b/src/main/java/com/code_intelligence/jazzer/driver/ExceptionUtils.kt
@@ -196,9 +196,9 @@ private fun readJavaFullFinalFlags(): String? {
 }
 
 fun dumpAllStackTraces() {
-    Log.println("\nStack traces of all JVM threads:")
+    Log.alwaysPrintln("\nStack traces of all JVM threads:")
     for ((thread, stack) in Thread.getAllStackTraces()) {
-        Log.println(thread.toString())
+        Log.alwaysPrintln(thread.toString())
         // Remove traces of this method and the methods it calls.
         stack
             .asList()
@@ -210,9 +210,9 @@ fun dumpAllStackTraces() {
                 )
             }.asReversed()
             .forEach { frame ->
-                Log.println("\tat $frame")
+                Log.alwaysPrintln("\tat $frame")
             }
-        Log.println("")
+        Log.alwaysPrintln("")
     }
 
     if (IS_ANDROID) {
@@ -220,8 +220,8 @@ fun dumpAllStackTraces() {
         return
     }
 
-    Log.println("Garbage collector stats:")
-    Log.println(
+    Log.alwaysPrintln("Garbage collector stats:")
+    Log.alwaysPrintln(
         ManagementFactory.getGarbageCollectorMXBeans().joinToString("\n", "\n", "\n") {
             "${it.name}: ${it.collectionCount} collections took ${it.collectionTime}ms"
         },
diff --git a/src/main/java/com/code_intelligence/jazzer/driver/FuzzTargetRunner.java b/src/main/java/com/code_intelligence/jazzer/driver/FuzzTargetRunner.java
index 112c4a2d..09377e0a 100644
--- a/src/main/java/com/code_intelligence/jazzer/driver/FuzzTargetRunner.java
+++ b/src/main/java/com/code_intelligence/jazzer/driver/FuzzTargetRunner.java
@@ -36,6 +36,8 @@ import com.code_intelligence.jazzer.utils.UnsafeProvider;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.math.BigInteger;
@@ -50,6 +52,7 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.Set;
+import java.util.Map;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import sun.misc.Unsafe;
@@ -287,6 +290,8 @@ public final class FuzzTargetRunner {
 
     long dedupToken = emitDedupToken ? ExceptionUtils.computeDedupToken(finding) : 0;
     if (emitDedupToken && !ignoredTokens.add(dedupToken)) {
+      if(Log.isExecutor) Log.finding(finding);
+      printAndDumpCrashingInput(true, finding);
       return LIBFUZZER_CONTINUE;
     }
     boolean continueFuzzing =
@@ -313,7 +318,7 @@ public final class FuzzTargetRunner {
       // We emit this line for backwards compatibility when fuzzing on the CLI only.
       Log.println("== libFuzzer crashing input ==");
     }
-    printAndDumpCrashingInput();
+    printAndDumpCrashingInput(continueFuzzing, finding);
 
     // dumpReproducer needs to be called after libFuzzer printed its final stats as otherwise it
     // would report incorrect coverage - the reproducer generation involved rerunning the fuzz
@@ -323,7 +328,7 @@ public final class FuzzTargetRunner {
     // It also doesn't support the mutator framework yet as that requires implementing Java code
     // generation for mutators.
     if (fatalFindingHandlerForJUnit == null && !useMutatorFramework) {
-      dumpReproducer(data);
+      //dumpReproducer(data);
     }
 
     if (!continueFuzzing) {
@@ -532,6 +537,23 @@ public final class FuzzTargetRunner {
   @SuppressWarnings("unused")
   private static void dumpAllStackTraces() {
     ExceptionUtils.dumpAllStackTraces();
+    Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces();
+    Thread mainThread = null;
+
+    for (Thread thread : allStackTraces.keySet()) {
+        if ("main".equals(thread.getName())) {
+            mainThread = thread;
+            break;
+        }
+    }
+    if (mainThread == null) return;
+    String msg = "";
+    StackTraceElement[] trace = allStackTraces.get(mainThread);
+    for (int i = 0; i < trace.length; i++) {
+        msg += "\tat " + trace[i].toString() + "\n";
+    }
+    Log.println(msg);
+    FuzzTargetRunnerNatives.unilAFLsetCrashLog(false, msg);
   }
 
   private static byte[] copyToArray(long ptr, int length) {
@@ -556,10 +578,22 @@ public final class FuzzTargetRunner {
    * Causes libFuzzer to write the current input to disk as a crashing input and emit some
    * information about it to stderr.
    */
-  public static void printAndDumpCrashingInput() {
+  public static void printAndDumpCrashingInput(boolean isContinue, Throwable t) {
+    String msg = "";
+    StackTraceElement[] trace = t.getStackTrace();
+    for (int i = 0; i < trace.length; i++) {
+        msg += "\tat " + trace[i].toString() + "\n";
+    }
+    if (trace.length == 0) {
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        t.printStackTrace(pw);
+        msg += sw.toString();
+    }
+    FuzzTargetRunnerNatives.unilAFLsetCrashLog(isContinue, msg);
     FuzzTargetRunnerNatives.printAndDumpCrashingInput();
   }
-
+  
   /** Returns the debug string of the current mutator. If no mutator is used, returns null. */
   public static String mutatorDebugString() {
     return mutator != null ? mutator.toString() : null;
diff --git a/src/main/java/com/code_intelligence/jazzer/driver/Opt.java b/src/main/java/com/code_intelligence/jazzer/driver/Opt.java
index 5840a7c1..9083ebf9 100644
--- a/src/main/java/com/code_intelligence/jazzer/driver/Opt.java
+++ b/src/main/java/com/code_intelligence/jazzer/driver/Opt.java
@@ -105,6 +105,20 @@ public final class Opt {
           "autofuzz_ignore",
           ',',
           "Fully qualified names of exception classes to ignore during fuzzing");
+  public static final OptItem<Boolean> uniaflCoverage =
+      boolSetting(
+          "uniafl_coverage", false, "Run as uniafl coverage mode");
+  public static final OptItem<String> redisURL =
+      stringSetting(
+          "redis_url",
+          "",
+          "Redis URL for syncing coverage id");
+  public static final OptItem<Boolean> uniaflPrepare =
+      boolSetting(
+          "uniafl_prepare", false, "Run as uniafl coverage prepare mode");
+  public static final OptItem<Boolean> uniaflDump =
+      boolSetting(
+          "uniafl_dump", false, "Run as uniafl coverage dump mode");
   public static final OptItem<String> coverageDump =
       stringSetting(
           "coverage_dump",
diff --git a/src/main/java/com/code_intelligence/jazzer/instrumentor/CoverageRecorder.kt b/src/main/java/com/code_intelligence/jazzer/instrumentor/CoverageRecorder.kt
index 0aab6ca8..7a5d134d 100644
--- a/src/main/java/com/code_intelligence/jazzer/instrumentor/CoverageRecorder.kt
+++ b/src/main/java/com/code_intelligence/jazzer/instrumentor/CoverageRecorder.kt
@@ -18,6 +18,7 @@ package com.code_intelligence.jazzer.instrumentor
 
 import com.code_intelligence.jazzer.runtime.CoverageMap
 import com.code_intelligence.jazzer.third_party.org.jacoco.core.analysis.CoverageBuilder
+import com.code_intelligence.jazzer.third_party.org.jacoco.core.analysis.ICounter
 import com.code_intelligence.jazzer.third_party.org.jacoco.core.data.ExecutionData
 import com.code_intelligence.jazzer.third_party.org.jacoco.core.data.ExecutionDataStore
 import com.code_intelligence.jazzer.third_party.org.jacoco.core.data.ExecutionDataWriter
@@ -38,12 +39,18 @@ private data class InstrumentedClassInfo(
     val bytecode: ByteArray,
 )
 
+data class UniAFLCovItem(val src: String, val lines: List<Int>)
+
 object CoverageRecorder {
     var classNameGlobber = ClassNameGlobber(emptyList(), emptyList())
     private val instrumentedClassInfo = mutableMapOf<String, InstrumentedClassInfo>()
     private var startTimestamp: Instant? = null
     private val additionalCoverage = mutableSetOf<Int>()
 
+    public fun hasInstrumentedClass(internalClassName: String): Boolean {
+        return instrumentedClassInfo.containsKey(internalClassName)
+    }
+
     fun recordInstrumentedClass(
         internalClassName: String,
         bytecode: ByteArray,
@@ -53,6 +60,7 @@ object CoverageRecorder {
         if (startTimestamp == null) {
             startTimestamp = Instant.now()
         }
+        if (hasInstrumentedClass(internalClassName)) return;
         instrumentedClassInfo[internalClassName] =
             InstrumentedClassInfo(
                 CRC64.classId(bytecode),
@@ -85,6 +93,53 @@ object CoverageRecorder {
         }
     }
 
+    fun dumpCoverageUniAFL(dumpFileName: String, coveredIds: IntArray) {
+        File(dumpFileName).bufferedWriter().use { writer ->
+            writer.write(computeUniAFLCoverage(coveredIds))
+        }
+    }
+
+
+    private fun computeUniAFLCoverage(coveredIds: IntArray): String {
+        val coverage = CoverageBuilder()
+        val executionDataStore = analyzeJacocoCoverage(coveredIds.toSet())
+        for ((internalClassName, info) in instrumentedClassInfo) {
+            EdgeCoverageInstrumentor(ClassInstrumentor.defaultEdgeCoverageStrategy, ClassInstrumentor.defaultCoverageMap, 0)
+                .analyze(
+                    executionDataStore,
+                    coverage,
+                    info.bytecode,
+                    internalClassName,
+                )
+        }
+        var cov_map = mutableMapOf<String, UniAFLCovItem>()
+        for (classCov in coverage.classes) {
+            val className = classCov.name.replace("/",".")
+            for (method in classCov.methods) {
+                val lines = (method.firstLine..method.lastLine).filter{i ->
+                    when (method.getLine(i).status)  {
+                        ICounter.FULLY_COVERED, ICounter.PARTLY_COVERED -> true
+                        else -> false
+                    }
+                }
+                if (lines.size > 0) {
+                    val name = "${className}.${method.name}${method.desc}"
+                    val src = if(classCov.packageName == "") { 
+                        classCov.sourceFileName 
+                    } else { 
+                        "${classCov.packageName}/${classCov.sourceFileName}" 
+                    }
+                    val item = UniAFLCovItem(src, lines)
+                    cov_map[name] = item
+                }
+            }
+        }
+
+        return "{\n"+cov_map.entries.joinToString(",\n") {
+            "  \"${it.key}\": {\"src\": \"${it.value.src}\", \"lines\": ${it.value.lines}}"
+        } + "\n}"
+    }
+
     private fun computeFileCoverage(coveredIds: IntArray): String {
         fun Double.format(digits: Int) = "%.${digits}f".format(this)
         val coverage = analyzeCoverage(coveredIds.toSet()) ?: return "No classes were instrumented"
diff --git a/src/main/java/com/code_intelligence/jazzer/jazzer_shade_rules.jarjar b/src/main/java/com/code_intelligence/jazzer/jazzer_shade_rules.jarjar
index 91073722..45540b14 100644
--- a/src/main/java/com/code_intelligence/jazzer/jazzer_shade_rules.jarjar
+++ b/src/main/java/com/code_intelligence/jazzer/jazzer_shade_rules.jarjar
@@ -4,3 +4,4 @@ rule kotlin.** com.code_intelligence.jazzer.third_party.@0
 rule net.** com.code_intelligence.jazzer.third_party.@0
 rule nonapi.** com.code_intelligence.jazzer.third_party.@0
 rule org.objectweb.** com.code_intelligence.jazzer.third_party.@0
+rule redis.** com.code_intelligence.jazzer.third_party.@0
diff --git a/src/main/java/com/code_intelligence/jazzer/runtime/FuzzTargetRunnerNatives.java b/src/main/java/com/code_intelligence/jazzer/runtime/FuzzTargetRunnerNatives.java
index 3b19c497..044bb2e0 100644
--- a/src/main/java/com/code_intelligence/jazzer/runtime/FuzzTargetRunnerNatives.java
+++ b/src/main/java/com/code_intelligence/jazzer/runtime/FuzzTargetRunnerNatives.java
@@ -37,6 +37,7 @@ public class FuzzTargetRunnerNatives {
   public static native int startLibFuzzer(
       byte[][] args, Class<?> runner, boolean useMutatorFramework);
 
+  public static native void unilAFLsetCrashLog(boolean is_continue, String err_msg);
   public static native void printAndDumpCrashingInput();
 
   public static native void temporarilyDisableLibfuzzerExitHook();
diff --git a/src/main/java/com/code_intelligence/jazzer/utils/Log.java b/src/main/java/com/code_intelligence/jazzer/utils/Log.java
index 555cc9c5..905c1550 100644
--- a/src/main/java/com/code_intelligence/jazzer/utils/Log.java
+++ b/src/main/java/com/code_intelligence/jazzer/utils/Log.java
@@ -35,6 +35,8 @@ public class Log {
 
   // Whether to print debug messages. This is controlled by the JAZZER_DEBUG environment variable.
   private static final boolean isDebug = System.getenv("JAZZER_DEBUG") != null;
+  private static final boolean isSilent = System.getenv("SILENT_MODE") != null;
+  public static final boolean isExecutor = System.getenv("EXECUTOR_MODE") != null;
 
   /** The {@link PrintStream}s to use for all output from this call on. */
   public static void fixOutErr(PrintStream out, PrintStream err) {
@@ -49,40 +51,53 @@ public class Log {
   }
 
   public static void println(String message) {
+    if(isSilent) return;
+    getErr().println(message);
+  }
+  
+  public static void alwaysPrintln(String message) {
     getErr().println(message);
   }
 
   public static void structuredOutput(String output) {
+    if(isSilent) return;
     getOut().println(output);
   }
 
   public static void debug(String message) {
+    if(isSilent) return;
     if (isDebug) {
       println("DEBUG: ", message, null);
     }
   }
 
   public static void info(String message) {
+    if(isSilent) return;
     println("INFO: ", message, null);
   }
 
   public static void warn(String message) {
+    if(isSilent) return;
     warn(message, null);
   }
 
   public static void warn(String message, Throwable t) {
+    if(isSilent) return;
     println("WARN: ", message, t);
   }
 
   public static void error(String message) {
+    if(isSilent) return;
     error(message, null);
   }
 
   public static void error(Throwable t) {
+    if(isSilent) return;
     error(null, t);
   }
 
   public static void error(String message, Throwable t) {
+    if(isSilent) return;
     println("ERROR: ", message, t);
   }
 
diff --git a/src/main/native/com/code_intelligence/jazzer/driver/coverage_tracker.cpp b/src/main/native/com/code_intelligence/jazzer/driver/coverage_tracker.cpp
index 58a05f1a..43ba2642 100644
--- a/src/main/native/com/code_intelligence/jazzer/driver/coverage_tracker.cpp
+++ b/src/main/native/com/code_intelligence/jazzer/driver/coverage_tracker.cpp
@@ -82,7 +82,7 @@ void CoverageTracker::RegisterNewCounters(JNIEnv &env, jint old_num_counters,
   // by libFuzzer.
   pc_entries_ = new PCTableEntry[diff_num_counters];
   for (std::size_t i = 0; i < diff_num_counters; ++i) {
-    pc_entries_[i] = {i, 0};
+    pc_entries_[i] = {i + old_num_counters, 0};
   }
   __sanitizer_cov_8bit_counters_init(counters_ + old_num_counters,
                                      counters_ + new_num_counters);
diff --git a/src/main/native/com/code_intelligence/jazzer/driver/fuzz_target_runner.cpp b/src/main/native/com/code_intelligence/jazzer/driver/fuzz_target_runner.cpp
index cdcfc308..4ac52754 100644
--- a/src/main/native/com/code_intelligence/jazzer/driver/fuzz_target_runner.cpp
+++ b/src/main/native/com/code_intelligence/jazzer/driver/fuzz_target_runner.cpp
@@ -201,6 +201,20 @@ Java_com_code_1intelligence_jazzer_runtime_FuzzTargetRunnerNatives_printAndDumpC
   }
 }
 
+extern bool is_fuzzing_end;
+extern char crash_logs[0x4000];
+[[maybe_unused]] void
+Java_com_code_1intelligence_jazzer_runtime_FuzzTargetRunnerNatives_unilAFLsetCrashLog(
+    JNIEnv *env, jclass, jboolean isContinue, jstring msg) {
+    jsize utfLength = env->GetStringUTFLength( msg);
+    if (utfLength >= sizeof(crash_logs)) {
+        utfLength = sizeof(crash_logs) - 1;
+    }
+    env->GetStringUTFRegion(msg, 0, utfLength, crash_logs);
+    crash_logs[utfLength] = 0;
+    is_fuzzing_end = (isContinue == JNI_FALSE);
+}
+
 namespace fuzzer {
 // Defined in:
 // https://github.com/llvm/llvm-project/blob/27cc31b64c0491725aa88a6822f0f2a2c18914d7/compiler-rt/lib/fuzzer/FuzzerLoop.cpp#L43
