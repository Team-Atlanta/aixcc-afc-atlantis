# Concolic Executor/Mutator

This directory contains the implementation of the concolic executor/mutator, a system designed to generate novel inputs by blending concrete execution with symbolic analysis.

## Directory Structure

* [`executor/`](executor/): Manages instrumentation and tracing artifacts. All sources within `prebuild/` are copied to the `multilang-builder` image for the construction of necessary binary components. 

* [`symstate/`](symstate/): Encapsulates the core logic for the concolic mutator. It defines the primary entrypoint, [`SymState`](symstate/mod.rs), responsible for the following sequential steps:
    1.  Parsing the execution trace generated by the instrumented target.
    2.  Processing the trace data to construct Z3 expressions representing path constraints.
    3.  Solving inverted path constraints to identify alternative execution paths.
    4.  Synthesizing the resulting Z3 model (symbolic assignments) back into concrete input(s).

* [`profile_data.rs`](profile_data.rs): Defines common data structures utilized for performance profiling.

---

## Core Components

### `symstate/`

This section details the [`SymState`](symstate/mod.rs) trait and its key methods, which serve as the primary entrypoint for symbolic mutation.

`SymState` is a Rust trait providing the core functionality for symbolic input mutation. Current implementations are [`SymQEMUSymState`](symstate/symcc_symqemu/symqemu.rs) and [`SymCCSymState`](symstate/symcc_symqemu/symcc.rs), each of which are purposed for concolic execution/solving in via SymQEMU and SymCC instrumented targets, respectively.

The most important method of the `SymState` trait is the `process(&mut self, input_id: InputID, input: &Input) -> Result<SymStateProcessResult, SymStateError>` method:
    This method processes a given input, returning a `SymStateProcessResult`, which encompasses a list of new inputs produced via concolic mutation. It invokes `concolic_mutation` if `input_id` represents a previously unobserved input. Otherwise, it calls `crossover()`, which generates new inputs through AFL-style crossover operations on saved solutions, without performing full concolic mutation. This is an optimization to avoid redundant concolic execution for inputs that have already been processed.

Implementing `SymState` requires the implementation of five sub-components:

1.  **Executor**: Responsible for executing the instrumented target and collecting the trace data.
2.  **[Trace Manager](symstate/common/trace_manager.rs)**: Responsible for parsing trace data and converting it into a solver-compatible format (Z3 ASTs).
3.  **[Solution Cache](symstate/common/solution_cache.rs)**: Stores solutions and manages `input_id` mappings. This component is shared across all `SymState` instances, protected by an `RwLock`, facilitating solution reuse.
4.  **[Solver](symstate/common/solver.rs)**: Responsible for solving the path constraints encoded in trace data. If a solution for the full sequence of path constraints is not found, it performs QSYM's [optimistic solving](https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-yun.pdf) (negating the last path constraint while retaining prior constraints) to find a solution.
5.  **[Solution to Input](symstate/common/solution_to_input.rs)**: Converts a Z3 model (a mapping from symbols to concrete values) into a concrete program input. For SymCC's QSYM backend, this is straightforward, as symbols always map directly to individual input bytes (e.g., `k#!0` to `k#!N`). However, we extended our concolic executor to support symbols that are not limited to byte-level input. For example, `ScanfExtract!%d%d!0` denotes the first integer value extracted by `scanf("%d%d", &n1, &n2)`. This allows `n1`'s value to be directly represented in the Z3 model and used in path constraints without explicit encoding of string-to-integer conversion logic to Z3 expressions.

---

### `executor/`

Two executor implementations exist: SymCC and SymQEMU, found in [`symcc.rs`](executor/symcc/symcc.rs) and [`symqemu.rs`](executor/symcc/symqemu.rs) respectively. Both implement the `ConcolicExecutor` trait, defining `execute()` and `execute_single_step()`. The `execute()` method takes an input and generates a complete trace. The `execute_single_step()` method executes the target program until the next branching instruction is encountered. This single-step mode is utilized by the [`self_correcting`](symstate/self_correction.rs) executor, designed to detect underconstrained expressions within the trace.

---

## Changes to SymCC / SymQEMU

We have introduced several modifications to the SymCC and SymQEMU instrumentation to enhance concolic execution and mutation capabilities.

#### SymCC Instrumentation Pass

* Path: `executor/symcc/prebuild/symcc-pass`
    Two primary bug fixes were applied to the SymCC instrumentation pass, both addressing issues related to vector types:
    * Corrected handling of vector types in `createValueExpression` within [`compiler/Symbolizer.cpp`](executor/symcc/prebuild/symcc-pass/compiler/Symbolizer.cpp).
    * Corrected handling of vector types in `visitBitCastInstruction` within `compiler/Symbolizer.cpp`.

#### SymCC Runtime

Instead of the default QSym backend runtime, we utilize a modified version of the `rust_runtime` from the LibAFL project. This runtime deviates from the QSym backend by not solving path constraints internally within the `_sym_push_path_constraint` function; instead, it returns them to the `SymState` concolic solver. This decoupling offers a complete separation of tracing from solving, enabling more optimizations.

Specific modifications to the LibAFL `rust_runtime` include:

1.  Enabled additional [`SymExpr`](executor/symcc/prebuild/LibAFL/libafl/src/observers/concolic/sym_expr.rs) instances, such as `ScanfExtract` and `DataLength`.
2.  Implemented vector-related runtime functions, e.g., [`_sym_build_vector_element_insert`](executor/symcc/prebuild/LibAFL/libafl_concolic/symcc_runtime/src/lib.rs).
3.  Significantly improved the readability and accuracy of [`runtime_macros`](executor/symcc/prebuild/LibAFL/libafl_concolic/symcc_runtime_macros/src/lib.rs). These macros, used to generate C headers for Rust-SymCC runtime bindings, were made more maintainable and extensible via `proc_macros`.
4.  Generic interception of all function calls via [`_sym_hook_function_call`](executor/symcc/prebuild/LibAFL/libafl_concolic/symcc_runtime/src/function_call_hook/mod.rs), replacing the previous `name_symbolized` approach for `libc` functions.
5.  Interception of intrinsics via [`_sym_hook_intrinsic_call`](executor/symcc/prebuild/LibAFL/libafl_concolic/symcc_runtime/src/lib.rs). While many key intrinsics (e.g., `memcpy`) are handled by the SymCC instrumentation pass, architecture-specific intrinsics (e.g., `llvm.x86.sse2.pcmpeqb`) are now handled within the runtime.
6.  These interceptors (points 4 and 5) redirect to a [Python script](symstate/hook_basic.py), allowing addition of new interceptors without recompilation of the runtime. This mechanism was initially conceived to leverage LLMs for interceptor generation; while early attempts with reasoning models were too unreliable to integrate into submission, more recent models (e.g., Claude's Opus4) show promising results for future exploration.

#### SymQEMU

1.  To minimize TCG (Tiny Code Generator) compilation time, the target harness is executed in continuous fuzzing mode, and the `LLVMFuzzerTestOneInput` function is intercepted to inject inputs during re-execution. This is implemented in [`libfuzzer-hooks.c`](executor/symcc/prebuild/symqemu-multilang/accel/tcg/libfuzzer/libfuzzer-hooks.c).
2.  TCG compilation is skipped for ASAN-related functions (e.g., `__asan_report_load_n`, `__asan_report_store_n`), as they are not pertinent to the concolic execution and mutation process. This is achieved by intercepting these function calls in the SymQEMU runtime and providing no-op implementations via [`libfuzzer_skip_trace_cov_func`](executor/symcc/prebuild/symqemu-multilang/accel/tcg/libfuzzer/libfuzzer-hooks.c).
