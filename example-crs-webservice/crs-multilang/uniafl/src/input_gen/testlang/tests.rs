use generators::testlang_generators;
use glob::glob;
use libafl::mutators::MutationResult;
use libafl_bolts::rands::StdRand;
use mutators::{testlang_havoc_mutators, testlang_normal_mutators};
use std::{
    collections::HashMap,
    env,
    path::Path,
    sync::Arc,
    time::{Duration, Instant},
};
use tempfile::tempdir;
use testlang::{custom::TYPE_IDS, TestLang};

use crate::{common::errors::ErrorKind, input_gen::testlang::mutators::testlang_ast_free_mutators};

use super::{generators::custom, service::worker::CustomGenRuntime, *};

fn load_testlangs() -> HashMap<String, TestLang> {
    let workspace_env = env::var("CARGO_MANIFEST_DIR").unwrap();
    let testlang_samples_dir = Path::new(&workspace_env)
        .join("../reverser/harness-reverser/answers")
        .to_string_lossy()
        .into_owned();
    let mut testlangs = HashMap::new();
    let glob_pattern = format!("{testlang_samples_dir}/*.json");
    for entry in glob(&glob_pattern).expect("Failed to listup sample files") {
        match entry {
            Ok(path) => {
                testlangs.insert(
                    path.file_stem().unwrap().to_string_lossy().into_owned(),
                    TestLang::from_file(&path).unwrap(),
                );
            }
            Err(e) => eprintln!("{:?}", e),
        }
    }
    testlangs
}

fn filter_acceptable_error<T>(result: Result<T, Error>) -> Result<(), Error> {
    match result {
        Ok(_) => Ok(()),
        Err(err) => match &err.kind {
            ErrorKind::LibAFLError { inner } => match inner {
                libafl::Error::IllegalArgument(msg, _)
                    if msg.contains("is larger than the given size range") =>
                {
                    Ok(())
                }
                libafl::Error::IllegalArgument(msg, _)
                    if msg.contains("Size not enough to generate array elements") =>
                {
                    Ok(())
                }
                _ => Err(err),
            },
            ErrorKind::TestLangError { inner }
                if inner.contains("Generated input is too long:") =>
            {
                Ok(())
            }
            _ => Err(err),
        },
    }
}

fn filter_acceptable_error_mutation(result: Result<MutationResult, Error>) -> Result<bool, Error> {
    match result {
        Ok(v) => Ok(v == MutationResult::Mutated),
        Err(err) => match &err.kind {
            ErrorKind::LibAFLError { inner } => match inner {
                libafl::Error::IllegalArgument(msg, _)
                    if msg.contains("is larger than the given size range") =>
                {
                    Ok(false)
                }
                _ => Err(err),
            },
            ErrorKind::TestLangError { inner }
                if inner.contains("Generated input is too long:") =>
            {
                Ok(false)
            }
            _ => Err(err),
        },
    }
}

#[test]
fn mutate() {
    let testlangs = load_testlangs();

    let mut cycle_count = 0;
    let mut effective_cycle_count = 0;
    let mut acc_time = Duration::from_nanos(0);
    let dummy_dir = tempdir().unwrap();

    let mut mutators = testlang_normal_mutators();
    mutators.append(&mut testlang_havoc_mutators());
    for (_path, testlang) in testlangs.iter() {
        let mut state = TestLangState::new(
            Arc::new(testlang.clone()),
            dummy_dir.path(),
            StdRand::new(),
            2097152,
        );
        let generators = testlang_generators();
        let mut bytes_output = Vec::new();
        let mut generated_outputs = Vec::new();
        for mut generator in generators {
            for _ in 0..8 {
                let mut metadata_output = None;
                bytes_output.clear();
                filter_acceptable_error(generator.generate(
                    &mut state,
                    &mut bytes_output,
                    &mut metadata_output,
                ))
                .unwrap();

                generated_outputs.push((metadata_output.unwrap(), bytes_output.len()));
                // Parse the generated bytes and check if it is valid
                // FIXME: Revert after parsing is fixed
                // let parsed = TestLangBlob::from_bytes(&output, testlang);
                // assert!(parsed.is_ok());
            }
        }

        let start_time = Instant::now();
        for mutator in &mut mutators {
            for (ast, input_len) in &generated_outputs {
                for _ in 0..32 {
                    let mut metadata_output = None;
                    bytes_output.clear();
                    let mutation_result = mutator.mutate(
                        &mut state,
                        ast,
                        *input_len,
                        &mut bytes_output,
                        &mut metadata_output,
                    );
                    if filter_acceptable_error_mutation(mutation_result).unwrap() {
                        // FIXME: Revert after parsing is fixed
                        // let _ = TestLangBlob::from_bytes(&output, testlang).unwrap();
                        effective_cycle_count += 1;
                    }
                    cycle_count += 1;
                }
            }
        }
        acc_time += start_time.elapsed();
    }

    let cycle_speed = cycle_count as f64 / acc_time.as_secs_f64();
    let cycle_time = acc_time.as_nanos() / cycle_count;
    let effective_cycle_speed = effective_cycle_count as f64 / acc_time.as_secs_f64();
    let effective_cycle_time = acc_time.as_nanos() / effective_cycle_count;

    println!("Total mutation calls: {cycle_count}, {cycle_speed} execs/sec, {cycle_time} ns/cycle");
    println!("Effective mutation calls: {effective_cycle_count}, {effective_cycle_speed} execs/sec, {effective_cycle_time} ns/cycle");
    println!("Elapsed Time: {:?}", acc_time);
}

#[test]
fn mutate_ast_free() {
    let testlangs = load_testlangs();

    let mut cycle_count = 0;
    let mut effective_cycle_count = 0;
    let mut acc_time = Duration::from_nanos(0);
    let dummy_dir = tempdir().unwrap();

    let mut mutators = testlang_ast_free_mutators();
    for (_path, testlang) in testlangs.iter() {
        let mut state = TestLangState::new(
            Arc::new(testlang.clone()),
            dummy_dir.path(),
            StdRand::new(),
            2097152,
        );
        let generators = testlang_generators();
        let mut generated_outputs = Vec::new();
        for mut generator in generators {
            for _ in 0..4 {
                let mut metadata_output = None;
                let mut bytes_output = Vec::new();
                filter_acceptable_error(generator.generate(
                    &mut state,
                    &mut bytes_output,
                    &mut metadata_output,
                ))
                .unwrap();
                generated_outputs.push(bytes_output);
                // Parse the generated bytes and check if it is valid
                // FIXME: Revert after parsing is fixed
                // let parsed = TestLangBlob::from_bytes(&output, testlang);
                // assert!(parsed.is_ok());
            }
        }

        let start_time = Instant::now();
        let mut bytes_output = Vec::new();
        for mutator in &mut mutators {
            for input in &generated_outputs {
                for _ in 0..256 {
                    bytes_output.clear();
                    let mutation_result = mutator.mutate(&mut state, input, &mut bytes_output);
                    if filter_acceptable_error_mutation(mutation_result).unwrap()
                        && &bytes_output != input
                    {
                        effective_cycle_count += 1;
                    }
                    cycle_count += 1;
                }
            }
        }
        acc_time += start_time.elapsed();
    }

    let cycle_speed = cycle_count as f64 / acc_time.as_secs_f64();
    let cycle_time = acc_time.as_nanos() / cycle_count;
    let effective_cycle_speed = effective_cycle_count as f64 / acc_time.as_secs_f64();
    let effective_cycle_time = acc_time.as_nanos() / effective_cycle_count;

    println!("Total mutation calls: {cycle_count}, {cycle_speed} execs/sec, {cycle_time} ns/cycle");
    println!("Effective mutation calls: {effective_cycle_count}, {effective_cycle_speed} execs/sec, {effective_cycle_time} ns/cycle");
    println!("Elapsed Time: {:?}", acc_time);
}

#[test]
fn generate() {
    let testlangs = load_testlangs();
    let mut cycle_count = 0;
    let mut acc_time = Duration::from_nanos(0);
    let dummy_dir = tempdir().unwrap();
    for (_path, testlang) in testlangs.iter() {
        let mut state = TestLangState::new(
            Arc::new(testlang.clone()),
            dummy_dir.path(),
            StdRand::new(),
            2097152,
        );
        let generators = testlang_generators();
        let start_time = Instant::now();
        let mut bytes_output = Vec::new();
        let mut metadata_output = None;
        for mut generator in generators {
            for _ in 0..512 {
                bytes_output.clear();
                filter_acceptable_error(generator.generate(
                    &mut state,
                    &mut bytes_output,
                    &mut metadata_output,
                ))
                .unwrap();
                // Parse the generated bytes and check if it is valid
                // FIXME: Revert after parsing is fixed
                // let parsed = TestLangBlob::from_bytes(&output, testlang);
                // assert!(parsed.is_ok());
                cycle_count += 1;
            }
        }
        acc_time += start_time.elapsed();
    }

    let cycle_speed = cycle_count as f64 / acc_time.as_secs_f64();
    let cycle_time = acc_time.as_nanos() / cycle_count;

    println!(
        "Total generation calls: {cycle_count}, {cycle_speed} execs/sec, {cycle_time} ns/cycle"
    );
    println!("Elapsed Time: {:?}", acc_time);
}

#[test]
fn generate_custom() {
    let mut customgen_runtime = CustomGenRuntime::new().unwrap();
    for gen_type_id in TYPE_IDS {
        if let Err(err) = custom::generate_one(&mut customgen_runtime, gen_type_id) {
            if let ErrorKind::TestLangError { inner } = &err.kind {
                if inner.contains("custom generation failed: output is empty") {
                    continue;
                }
            }
            panic!("{:?}", err);
        }
    }
}
