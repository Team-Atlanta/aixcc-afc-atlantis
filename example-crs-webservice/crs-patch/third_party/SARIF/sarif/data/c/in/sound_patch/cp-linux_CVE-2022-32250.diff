--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -5033,7 +5033,7 @@
 int nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,
 		       struct nft_set_binding *binding)
 {
-	struct nft_set_binding *i;
+	struct nft_set_binding *i, *b;
 	struct nft_set_iter iter;
 
 	if (!list_empty(&set->bindings) && nft_set_is_anonymous(set))
@@ -5044,13 +5044,13 @@
 		 * jumps are already validated for that chain.
 		 */
 		list_for_each_entry(i, &set->bindings, list) {
-			if (i->flags & NFT_SET_MAP &&
+			if ((i->flags & NFT_SET_MAP) &&
 			    i->chain == binding->chain)
 				goto bind;
 		}
 
 		iter.genmask	= nft_genmask_next(ctx->net);
-		iter.skip 	= 0;
+		iter.skip	= 0;
 		iter.count	= 0;
 		iter.err	= 0;
 		iter.fn		= nf_tables_bind_check_setelem;
@@ -5066,8 +5066,12 @@
 	if (!nft_use_inc(&set->use))
 		return -EMFILE;
 
-	binding->chain = ctx->chain;
-	list_add_tail_rcu(&binding->list, &set->bindings);
+	b = kmemdup(binding, sizeof(*binding), GFP_KERNEL);
+	if (!b)
+		return -ENOMEM;
+
+	b->chain = ctx->chain;
+	list_add_tail_rcu(&b->list, &set->bindings);
 	nft_set_trans_bind(ctx, set);
 
 	return 0;
