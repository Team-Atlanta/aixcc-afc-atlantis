--- a/net/tipc/crypto.c
+++ b/net/tipc/crypto.c
@@ -2278,15 +2278,14 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
 	struct tipc_crypto *tx  = NULL;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
+
+	if (rx->net) {
 		tx = tipc_net(rx->net)->crypto_tx;
 	}
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
@@ -2298,6 +2297,13 @@
 		goto exit;
 	}
 
+	/* Validate that the size is sufficient for alg name, key length field and key data */
+	if (TIPC_AEAD_ALG_NAME + sizeof(__be32) + keylen > size) {
+		pr_err("%s: invalid key length (%u) for size %u\n",
+		       rx->name, keylen, size);
+		goto exit;
+	}
+
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
@@ -2320,9 +2326,9 @@
 exit:
 	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
-	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
-		return true;
+	if (rx->net) {
+		if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+			return true;
 	}
 	return false;
 }
