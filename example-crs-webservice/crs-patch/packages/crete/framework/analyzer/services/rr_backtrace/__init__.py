import json
from pathlib import Path
from typing import Any, Callable, Dict, cast

from crete.commons.interaction.exceptions import CommandInteractionError
from python_docker.image.functions import docker_image_exists
from python_oss_fuzz.path.globals import (
    TEAM_ATLANTA_DOCKER_REGISTRY,
    TEAM_ATLANTA_IMAGE_VERSION,
    OSS_FUZZ_RR_BACKTRACER_OUT_DIRECTORY,
    OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY,
)
from python_oss_fuzz.rr.functions import copy_rr_backtracer, copy_rr_dir

from crete.atoms.detection import Detection
from crete.commons.docker.functions import docker_execute, create_docker_mount_args
from crete.framework.environment.contexts import EnvironmentContext
from crete.framework.evaluator.contexts import EvaluatingContext

RR_OSSFUZZ_PATH = "/work/rr/bin/rr"
BACKTRACER_OUT_PATH = "/work/backtracer.out"
RR_BACKTRACER_IMAGE_NAME = (
    f"{TEAM_ATLANTA_DOCKER_REGISTRY}/rr-backtracer:{TEAM_ATLANTA_IMAGE_VERSION}"
)


# rr-backtracer runs under the separate image named "gcr.io/oss-fuzz-base/rr-backtracer", which is based on the base-runner-debug image.
# Note that the image is created by pre_build_oss_fuzz_images() function in the `scripts/setup.py`
class RRBacktraceAnalyzer:
    """
    Runs rr-backtracer to extract functions responsible for making invalid memory access
    (e.g., 0x41414141 in `mov rax, [rbx]`).
    Basically this is done by tracking write operations of each instructions using reverse execution of RR.
        * rr-backtracer: https://github.com/Team-Atlanta/rr-backtracer
    """

    def __init__(self):
        if not OSS_FUZZ_RR_BACKTRACER_OUT_DIRECTORY.exists():
            OSS_FUZZ_RR_BACKTRACER_OUT_DIRECTORY.mkdir(parents=True)
        if not OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY.exists():
            OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY.mkdir(parents=True)

    def analyze(
        self, context: EvaluatingContext, detection: Detection, timeout: int = 0x0
    ) -> Dict[str, Any] | None:
        return cast(
            Callable[..., Dict[str, Any] | None],
            context["memory"].cache(self._analyze, ignore=["context"]),  # pyright: ignore[reportUnknownMemberType]
        )(context, detection, timeout)

    def _analyze(
        self, context: EvaluatingContext, detection: Detection, timeout: int = 0x0
    ) -> Dict[str, Any] | None:
        environment = context["pool"].use(context, "DEBUG")
        if environment is None:
            context["logger"].warning("No debug environment found")
            return None

        assert docker_image_exists(RR_BACKTRACER_IMAGE_NAME), (
            f"docker image {RR_BACKTRACER_IMAGE_NAME} does not exist."
        )

        assert len(detection.blobs) > 0, "At least one blob is required"

        # @TODO: is there any ID corresponding to each detection? (such as hash).
        outdir_name = f"backtracer.{detection.blobs[0].harness_name}.out"

        # To avoid unexpected behaviors, clean-up existing output directory.
        # Since these files are produced with root privilege, remove it with the privileged docker.
        _cleanup_files_with_docker(outdir_name)
        _cleanup_files_with_docker(
            "backtracer"
        )  # pycache files requires root permission.

        _prepare_files(detection)

        # commandline that executes PoV in the container
        # harness is located in container's /out directory
        harness_cmd = f"/out/{detection.project_name}/{detection.blobs[0].harness_name} /work/blob.bin"

        addr_dict = _run_target_extractor(context, outdir_name, harness_cmd)

        if addr_dict is None:
            context["logger"].error(
                "RRBacktraceAnalyzer: target address extraction failed..."
            )
            return None

        return _run_backtracer(
            context, outdir_name, harness_cmd, addr_dict["target_addr"], timeout
        )


def _prepare_files(detection: Detection):
    """
    Prepare files (PoC file, RR debugger executables, and backtracer component) for the rr-backtracer to run.

    All files are written to the work_directory of OSS-Fuzz.
    """

    assert len(detection.blobs) > 0, "At least one blob is required"
    poc_path = OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY / "blob.bin"
    poc_path.write_bytes(detection.blobs[0].blob)

    # prepare RR debugger binaries and rr-backtracer in OSS-Fuzz's work directory.
    copy_rr_dir()
    copy_rr_backtracer()


def _cleanup_files_with_docker(path: str):
    """
    Since backtracer's output is generated by privileged docker,
    it suffers from permission denied issue (because existing output directory is at root permission).
    To avoid such problem, remove the directory also through the privileged docker.
    """
    cmd = ["rm", "-rf", f"/work/{path}"]
    docker_execute(
        image=RR_BACKTRACER_IMAGE_NAME,
        cmd=cmd,
        files_to_mount=create_docker_mount_args(
            out_directory=OSS_FUZZ_RR_BACKTRACER_OUT_DIRECTORY,
            work_directory=OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY,
        ),
    )


def _run_backtracer(
    context: EnvironmentContext,
    outdir_name: str,
    harness_cmd: str,
    target_addr: int,
    timeout: int,
) -> Dict[str, Any] | None:
    """
    Run rr-backtracer on the docker environment (`gcr.io/oss-fuzz-base/rr-backtracer` image).
    Note that its result can be found in "backtracer.out/graph.json" of OSS-Fuzz's working directory.

    Parameters:
        @detection: a target PoC detection.
        @target_addr: target instruction address for tracking its origins.
        @timeout: Upper bound timeout value (second) for execution time (i.e., this analysis will be forcifully finished when it reaches this time).

    Return:
        JSON formatted output graph.
    """
    cmd = [
        "python3",
        "/work/backtracer/run.py",
        "-o",
        f"/work/{outdir_name}",
        "--target_addr",
        hex(target_addr),
        "--rr",
        RR_OSSFUZZ_PATH,
        "--cmd",
        harness_cmd,
        "--timeout",
        str(timeout),
    ]

    try:
        docker_execute(
            image=RR_BACKTRACER_IMAGE_NAME,
            cmd=cmd,
            files_to_mount=create_docker_mount_args(
                out_directory=OSS_FUZZ_RR_BACKTRACER_OUT_DIRECTORY,
                work_directory=OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY,
            ),
        )
    except CommandInteractionError as e:
        context["logger"].error(f"_run_backtracer: {cmd} failed: {e}")
        return None

    # check output json file
    output_json_path: Path = (
        OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY / outdir_name / "graph.json"
    )

    return _get_json(output_json_path)


def _run_target_extractor(
    context: EnvironmentContext, outdir_name: str, harness_cmd: str
) -> Dict[str, int] | None:
    """
    Automatically extract target address from crashing execution for rr-backtracer.
    Note that its result can be found in "backtracer.out/target_addr.json" of OSS-Fuzz's working directory.

    Parameters:
        @detection: a target PoC detection.

    Return:
        JSON formatted dict with address to start backtrace.
    """

    cmd = [
        "python3",
        "/work/backtracer/extract_target.py",
        "-o",
        f"/work/{outdir_name}",
        "--rr",
        RR_OSSFUZZ_PATH,
        "--cmd",
        f"{harness_cmd}",
    ]

    try:
        docker_execute(
            image=RR_BACKTRACER_IMAGE_NAME,
            cmd=cmd,
            files_to_mount=create_docker_mount_args(
                out_directory=OSS_FUZZ_RR_BACKTRACER_OUT_DIRECTORY,
                work_directory=OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY,
            ),
        )
    except CommandInteractionError as e:
        context["logger"].error(f"_run_target_extractor: {cmd} failed: {e}")
        return None

    # check output json file
    output_json_path: Path = (
        OSS_FUZZ_RR_BACKTRACER_WORKING_DIRECTORY / outdir_name / "target_addr.json"
    )

    return _get_json(output_json_path)


def _get_json(json_path: Path) -> Any:
    if not json_path.exists():
        return None

    # Return the json-formatted output
    with open(json_path, "r") as f:
        output_json = json.load(f)

    return output_json
