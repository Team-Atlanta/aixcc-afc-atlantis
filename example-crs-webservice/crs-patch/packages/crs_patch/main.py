# generated by fastapi-codegen:
#   filename:  crs-patch.json
#   timestamp: 2025-03-18T00:57:58+00:00

from __future__ import annotations

import asyncio
import json
import logging
import os
import time
from contextlib import asynccontextmanager
from pathlib import Path
from uuid import UUID

import requests
from crs_patch.models import (
    Config,
    Error,
    PatchRequest,
    PatchStatus,
    Status,
    SubmissionStatus,
)
from crs_patch.services.patch_checker import PatchChecker
from crs_patch.services.patch_manager import PatchManager
from crs_patch.services.request_handler import RequestHandler
from crs_patch.services.submitter import Submitter
from crs_patch.utils.challenges import (
    construct_challenge_mode,
    setup_challenge_project,
    setup_oss_fuzz_projects,
)
from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.responses import JSONResponse
from libCRS.otel import install_otel_logger

from scripts.setup import system_check

SOURCE_DIRECTORY = Path.home() / "cp_sources"

SLEEP_TIME = 60


@asynccontextmanager
async def lifespan(app: FastAPI):
    install_otel_logger(action_name="crs-patch-main")

    check_environments()

    project_name = os.environ["CRS_TARGET"]
    tarfile_directory = Path(os.environ["TARBALL_DIR"])
    task_id = os.environ["TASK_ID"]

    challenge_project_directory = setup_challenge_project(
        tarfile_directory, SOURCE_DIRECTORY
    )
    setup_oss_fuzz_projects(SOURCE_DIRECTORY)

    system_check()

    patch_checker = PatchChecker()
    patch_checker.initialize(tarfile_directory)

    assert patch_checker.build_image(project_name), (
        f"Failed to build image for {project_name}"
    )

    patch_manager = PatchManager(
        project_name,
        construct_challenge_mode(challenge_project_directory, "full"),
        challenge_project_directory,
    )

    global submitter
    submitter = Submitter()

    subconfigs_json = json.loads((Path(__file__).parent / "configs.json").read_text())

    global request_handler
    request_handler = RequestHandler(
        task_id=task_id,
        subconfigs=[Config(**config) for config in subconfigs_json],
        patch_manager=patch_manager,
        submitter=submitter,
    )

    submitter.register_callback(request_handler.handle_submission_callback)
    submitter.register_callback(patch_manager.remove_patch)

    handler_task = asyncio.create_task(request_handler.handle())
    submitter_task = asyncio.create_task(submitter.handle_submit_result())

    subconfigs = [Config(**config) for config in subconfigs_json]
    while subconfigs:
        try:
            for config in subconfigs:
                healthcheck = requests.get(request_handler.get_subnode_url(config))
                logging.info(
                    f"crs-patch-sub-{config.id} is ready: {healthcheck.status_code}"
                )
                subconfigs.remove(config)
        except requests.exceptions.ConnectionError:
            logging.info("Waiting for sub containers to be ready")
            time.sleep(SLEEP_TIME)
        except Exception as e:
            logging.error(
                f"Unexpected error while waiting sub containers: {e}", exc_info=True
            )
            time.sleep(SLEEP_TIME)

    yield

    handler_task.cancel()
    submitter_task.cancel()


def check_environments():
    load_dotenv(override=True)

    required_envvars = [
        "CRS_TARGET",
        "TARBALL_DIR",
        "VAPI_HOST",
        "TASK_ID",
    ]

    for envvar in required_envvars:
        assert os.environ.get(envvar) is not None, f"{envvar} is not set"


app = FastAPI(
    title="CRS Patch Generation API",
    version="1.0.0",
    lifespan=lifespan,
)


@app.post(
    "/v1/patch/",
    response_model=None,
    responses={"400": {"model": Error}, "500": {"model": Error}},
    tags=["patch"],
)
async def post_v1_patch_(body: PatchRequest) -> JSONResponse:
    """
    Request Patch Generation
    """
    try:
        await request_handler.put(body)
        return JSONResponse(
            status_code=200, content={"message": "Patch generation started"}
        )
    except Exception as e:
        return JSONResponse(status_code=500, content={"message": str(e)})


@app.get(
    "/v1/patch/{pov_id}/",
    response_model=PatchStatus,
    responses={
        "400": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def get_v1_patch_pov_id_(pov_id: UUID) -> JSONResponse:
    """
    Patch Status
    """
    try:
        status = request_handler.get_status(pov_id)
        if status is None:
            return JSONResponse(status_code=404, content={"message": "Not found"})

        result = status.model_copy()
        submitter_status = submitter.get_status(pov_id)
        if submitter_status is not None:
            match submitter_status:
                case SubmissionStatus.passed:
                    result.status = Status.succeeded
                case SubmissionStatus.failed:
                    result.status = Status.failed
                case SubmissionStatus.accepted:
                    result.status = Status.processing
                case SubmissionStatus.deadline_exceeded:
                    result.status = Status.errored
                case SubmissionStatus.errored:
                    result.status = Status.errored
                case SubmissionStatus.duplicated:
                    result.status = Status.errored

        return JSONResponse(status_code=200, content=result.model_dump(mode="json"))
    except Exception as e:
        return JSONResponse(status_code=500, content={"message": str(e)})
