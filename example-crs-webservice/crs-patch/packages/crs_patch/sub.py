# generated by fastapi-codegen:
#   filename:  crs-patch.json
#   timestamp: 2025-03-18T00:57:58+00:00

from __future__ import annotations

import asyncio
import importlib
import logging
import os
import random
import subprocess
import time
from contextlib import asynccontextmanager
from pathlib import Path
from typing import List
from uuid import UUID

from crete.atoms.path import DEFAULT_CACHE_DIRECTORY
from crete.framework.crete import Crete
from crs_patch.functions import get_environment_context, init_environment_pool
from crs_patch.models import Error, PatchRequest, PatchStatus
from crs_patch.services.patch_checker import PatchChecker
from crs_patch.services.request_handler import RoundRobinHandler
from crs_patch.utils.challenges import (
    construct_challenge_mode,
    setup_challenge_project,
    setup_oss_fuzz_projects,
)
from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.responses import JSONResponse
from libCRS.otel import install_otel_logger

from scripts.setup import main as setup_crete

logger = logging.getLogger(__name__)

SOURCE_DIRECTORY = Path.home() / "cp_sources"
APP_NAME = os.environ.get("APP_NAME", "")

logger = logging.getLogger(__name__)


def check_environments():
    load_dotenv(override=True)

    required_envvars = [
        "CRS_TARGET",
        "LITELLM_API_KEY",
        "LITELLM_API_BASE",
        "REGISTRY",
        "IMAGE_VERSION",
        "TARBALL_DIR",
        "APP_MODULE",
        "APP_NAME",
        "PROJECT_LANGUAGE",
    ]

    for envvar in required_envvars:
        assert os.environ.get(envvar) is not None, f"{envvar} is not set"


def load_apps() -> List[Crete]:
    app_modules = os.environ["APP_MODULE"].split(":")
    return [importlib.import_module(app_module).app for app_module in app_modules]


@asynccontextmanager
async def lifespan(app: FastAPI):
    install_otel_logger(action_name=f"crs-patch-{APP_NAME}")

    check_environments()

    project_name = os.environ["CRS_TARGET"]
    tarfile_directory = Path(os.environ["TARBALL_DIR"])
    challenge_project_directory = setup_challenge_project(
        tarfile_directory, SOURCE_DIRECTORY
    )
    setup_oss_fuzz_projects(SOURCE_DIRECTORY)

    patch_checker = PatchChecker()
    patch_checker.initialize(tarfile_directory)
    assert patch_checker.build_image(project_name), (
        f"Failed to build image for {project_name}"
    )

    for _ in range(32):
        try:
            setup_crete(project_name, challenge_project_directory)
            break
        except Exception as e:
            logger.error(f"Failed to setup crete: {e}")
            time.sleep(random.randint(10, 60))

    _make_crete_environments_cache(project_name, challenge_project_directory)

    output_directory = Path.home() / "crete-output"
    shared_directory = tarfile_directory / f"crs-patch-{APP_NAME}"
    os.makedirs(output_directory, exist_ok=True)

    global request_handler

    apps = load_apps()

    request_handler = RoundRobinHandler(
        challenge_project_directory=challenge_project_directory,
        output_directory=output_directory,
        cache_directory=Path.home() / ".cache" / "crete",
        patch_checker=patch_checker,
        apps=apps,
    )

    handler_task = asyncio.create_task(request_handler.handle())
    yield
    handler_task.cancel()
    save_output_directory(output_directory, shared_directory)


def save_output_directory(output_directory: Path, shared_directory: Path):
    subprocess.run(
        f"rsync -a --delete {output_directory}/ {shared_directory}",
        shell=True,
    )


app = FastAPI(
    title="CRS Patch Generation API",
    version="1.0.0",
    lifespan=lifespan,
)


@app.post(
    "/v1/patch/",
    response_model=None,
    responses={"400": {"model": Error}, "500": {"model": Error}},
    tags=["patch"],
)
async def post_v1_patch_(body: PatchRequest) -> JSONResponse:
    """
    Request Patch Generation
    """
    try:
        await request_handler.put(body)
        return JSONResponse(
            status_code=200, content={"message": "Patch generation started"}
        )
    except Exception as e:
        return JSONResponse(status_code=500, content={"message": str(e)})


@app.get(
    "/v1/patch/{pov_id}/",
    response_model=PatchStatus,
    responses={
        "400": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def get_v1_patch_pov_id_(pov_id: UUID) -> JSONResponse:
    """
    Patch Status
    """
    try:
        status = request_handler.get_status(pov_id)
        if status is None:
            return JSONResponse(status_code=404, content={"message": "Not found"})
        return JSONResponse(status_code=200, content=status.model_dump(mode="json"))
    except Exception as e:
        return JSONResponse(status_code=500, content={"message": str(e)})


def _make_crete_environments_cache(
    project_name: str, challenge_project_directory: Path
):
    environment_context = get_environment_context(
        logger, "address", DEFAULT_CACHE_DIRECTORY
    )
    init_environment_pool(
        environment_context,
        project_name,
        construct_challenge_mode(challenge_project_directory, "full"),
        challenge_project_directory,
    )
