# DO NOT EDIT THIS FILE.
# This file is automatically generated by `scripts/make_detections.py`

vulnerability_identifier = "custom-jvm-cxf-cpv-1-sarif-pov"
project_name = "aixcc/jvm/cxf"
sarif_report = "{\"runs\": [{\"artifacts\": [{\"location\": {\"index\": 0, \"uri\": \"rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/mtom/AttachmentUtil.java\"}}], \"automationDetails\": {\"id\": \"/\"}, \"conversion\": {\"tool\": {\"driver\": {\"name\": \"GitHub Code Scanning\"}}}, \"results\": [{\"correlationGuid\": \"2bc26b18-b683-4874-be9e-06108b3bf333\", \"level\": \"warning\", \"locations\": [{\"physicalLocation\": {\"artifactLocation\": {\"index\": 0, \"uri\": \"rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/type/mtom/AttachmentUtil.java\"}, \"region\": {\"endColumn\": 1, \"endLine\": 77, \"startColumn\": 1, \"startLine\": 71}}}], \"message\": {\"text\": \"Server-Side Request Forgery (SSRF) vulnerability in Aegis AttachmentUtil.getAttachment() allows attackers to make arbitrary HTTP requests from the server. The vulnerable code 'URLDataSource source = new URLDataSource(new URL(id))' unconditionally attempts to load remote URLs when attachments are not found locally, enabling attackers to send requests to internal services, perform port scanning, or exfiltrate data by providing malicious attachment IDs.\"}, \"partialFingerprints\": {\"primaryLocationLineHash\": \"a17cbcafe13f3e5d:1\"}, \"properties\": {\"github/alertNumber\": 2, \"github/alertUrl\": \"https://api.github.com/repos/aixcc-afc/cp-user-/code-scanning/alerts/2\"}, \"rule\": {\"id\": \"CWE-918\", \"index\": 0}, \"ruleId\": \"CWE-918\"}], \"tool\": {\"driver\": {\"name\": \"CodeScan++\", \"rules\": [{\"defaultConfiguration\": {\"level\": \"warning\"}, \"fullDescription\": {\"text\": \"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination. By providing URLs to unexpected hosts or ports, attackers can make it appear that the server is sending the request, possibly bypassing access controls such as firewalls that prevent the attackers from accessing the URLs directly. The server can be used as a proxy to conduct port scanning of hosts in internal networks, use other protocols such as gopher or file://, or read sensitive data from services that are not intended to be accessible to external users.\"}, \"helpUri\": \"https://cwe.mitre.org/\", \"id\": \"CWE-918\", \"properties\": {}, \"shortDescription\": {\"text\": \"Server-Side Request Forgery (SSRF)\"}}], \"version\": \"1.0.0\"}}, \"versionControlProvenance\": [{\"branch\": \"refs/heads/main\", \"repositoryUri\": \"https://github.com/Team-Atlanta/cp-java-cxf-src\", \"revisionId\": \"3ef4fdef7a4334b0a2a1153e7c516875e10c9c7b\"}]}], \"$schema\": \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\", \"version\": \"2.1.0\"}"
[[blobs]]
harness_name = "CXFTwo"
sanitizer_name = "address"
blob = "anVua19pZABodHRwczovL2phenplci5leGFtcGxlLmNvbS9yb2JvdHMudHh0"

[mode]
type = "full"
base_ref = "3ef4fdef7a4334b0a2a1153e7c516875e10c9c7b"
